/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],n):n((e="undefined"!=typeof globalThis?globalThis:e||self).tf=e.tf||{},e.tf)}(this,(function(e,n){"use strict";function t(e){if(e&&e.__esModule)return e;var n=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var r=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(n,t,r.get?r:{enumerable:!0,get:function(){return e[t]}})}})),n.default=e,n}var r=t(n),i=function(e,n){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t])})(e,n)};function o(e,n,t,r){return new(t||(t=Promise))((function(i,o){function a(e){try{s(r.next(e))}catch(e){o(e)}}function u(e){try{s(r.throw(e))}catch(e){o(e)}}function s(e){var n;e.done?i(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(a,u)}s((r=r.apply(e,n||[])).next())}))}function a(e,n){var t,r,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function u(o){return function(u){return function(o){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,r&&(i=2&o[0]?r.return:o[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,o[1])).done)return i;switch(r=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,r=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=a.trys,(i=i.length>0&&i[i.length-1])||6!==o[0]&&2!==o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=n.call(e,a)}catch(e){o=[6,e],r=0}finally{t=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,u])}}}function u(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}function s(e,n){var t="function"==typeof Symbol&&e[Symbol.iterator];if(!t)return e;var r,i,o=t.call(e),a=[];try{for(;(void 0===n||n-- >0)&&!(r=o.next()).done;)a.push(r.value)}catch(e){i={error:e}}finally{try{r&&!r.done&&(t=o.return)&&t.call(o)}finally{if(i)throw i.error}}return a}function l(){for(var e=[],n=0;n<arguments.length;n++)e=e.concat(s(arguments[n]));return e}var d,p=n.env();p.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(function(){return 15})),p.registerFlag("WEBGPU_CPU_FORWARD",(function(){return!0})),p.registerFlag("WEBGPU_MATMUL_WORK_PER_THREAD",(function(){return 4})),p.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(function(){return!1})),p.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(function(){return!1})),p.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(function(){return 1e3})),p.registerFlag("WEBGPU_USE_PROFILE_TOOL",(function(){return!1})),p.registerFlag("WEBGPU_USE_IMPORT",(function(){return!1})),function(e){e[e.MUL=0]="MUL",e[e.ADD=1]="ADD",e[e.SUB=2]="SUB",e[e.DIV=3]="DIV",e[e.EQUAL=4]="EQUAL",e[e.GREATER=5]="GREATER",e[e.GREATER_EQUAL=6]="GREATER_EQUAL",e[e.LESS=7]="LESS",e[e.LESS_EQUAL=8]="LESS_EQUAL",e[e.LOGICAL_AND=9]="LOGICAL_AND",e[e.NOT_EQUAL=10]="NOT_EQUAL",e[e.SQUARED_DIFFERENCE=11]="SQUARED_DIFFERENCE",e[e.INT_DIV=12]="INT_DIV",e[e.POW=13]="POW",e[e.PRELU=14]="PRELU",e[e.MAX=15]="MAX",e[e.MIN=16]="MIN",e[e.COMPLEX_MULTIPLY_REAL=17]="COMPLEX_MULTIPLY_REAL",e[e.COMPLEX_MULTIPLY_IMAG=18]="COMPLEX_MULTIPLY_IMAG"}(d||(d={}));var c,h="\n  if (isNaN.r) {\n    resultTemp.r = uniforms.NAN;\n  }\n  if (isNaN.g) {\n    resultTemp.g = uniforms.NAN;\n  }\n  if (isNaN.b) {\n    resultTemp.b = uniforms.NAN;\n  }\n  if (isNaN.a) {\n    resultTemp.a = uniforms.NAN;\n  }\n  ";function f(e,n){var t=n?h:"\n  if (isnan(a)) { return a; }\n  if (isnan(b)) { return b; }\n  ";return n?"\n    var resultTemp = vec4<f32>("+e+"(a, b));\n    let isNaN = isnanVec4(a) | isnanVec4(b);\n    "+t+"\n    return resultTemp;\n  ":t+"\n    return "+e+"(a, b);\n  "}function m(e,n){switch(e){case d.MUL:return"return a * b;";case d.ADD:return"return a + b;";case d.SUB:return"return a - b;";case d.DIV:return"return a / b;";case d.EQUAL:return n?"return vec4<f32>(a == b);":"return f32(a == b);";case d.GREATER:return n?"return vec4<f32>(a > b);":"return f32(a > b);";case d.GREATER_EQUAL:return n?"return vec4<f32>(a >= b);":"return f32(a >= b);";case d.LESS:return n?"return vec4<f32>(a < b);":"return f32(a < b);";case d.LESS_EQUAL:return n?"return vec4<f32>(a <= b);":"return f32(a <= b);";case d.LOGICAL_AND:return n?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(f32(a) >= 1.0 && f32(b) >= 1.0);";case d.NOT_EQUAL:return n?"return vec4<f32>(a != b);":"return f32(a != b);";case d.SQUARED_DIFFERENCE:return"return (a - b) * (a - b);";case d.INT_DIV:return n?"\n  let ia = vec4<i32>(round(a));\n  let ib = vec4<i32>(round(b));\n  let cond = ib != vec4<i32>(0);\n  var resultTemp = vec4<i32>(0);\n  let s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    resultTemp[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    resultTemp[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    resultTemp[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    resultTemp[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4<f32>(resultTemp);\n  ":"\n  let s = sign(a) * sign(b);\n  let ia = i32(round(a));\n  let ib = i32(round(b));\n  return f32(idiv(ia, ib, s));\n  ";case d.PRELU:return n?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n  ":"if (a < 0.0) { return b * a; }  return a;";case d.MAX:return f("max",n);case d.MIN:return f("min",n);case d.POW:return n?"\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = a < vec4<f32>(0.0) & floor(b) < b;\n  \n  if (isNaN.r) {\n    resultTemp.r = uniforms.NAN;\n  }\n  if (isNaN.g) {\n    resultTemp.g = uniforms.NAN;\n  }\n  if (isNaN.b) {\n    resultTemp.b = uniforms.NAN;\n  }\n  if (isNaN.a) {\n    resultTemp.a = uniforms.NAN;\n  }\n  \n  return resultTemp;\n  ":"\n  if(a < 0.0 && floor(b) < b) {\n    return uniforms.NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  if (round(abs(b) % 2.0) != 1.0) {\n    return pow(abs(a), b);\n  }\n  return sign(a) * pow(abs(a), b);\n  ";case d.COMPLEX_MULTIPLY_REAL:return"return areal * breal - aimag * bimag;";case d.COMPLEX_MULTIPLY_IMAG:return"return areal * bimag + aimag * breal;";default:throw new Error("BinaryType "+e+" is not implemented!")}}!function(e){e[e.ABS=0]="ABS",e[e.CEIL=1]="CEIL",e[e.COS=2]="COS",e[e.COSH=3]="COSH",e[e.ELU=4]="ELU",e[e.EXP=5]="EXP",e[e.EXPM1=6]="EXPM1",e[e.FLOOR=7]="FLOOR",e[e.LINEAR=8]="LINEAR",e[e.LOG=9]="LOG",e[e.LOGICAL_NOT=10]="LOGICAL_NOT",e[e.NEG=11]="NEG",e[e.RELU=12]="RELU",e[e.RELU6=13]="RELU6",e[e.LEAKYRELU=14]="LEAKYRELU",e[e.RSQRT=15]="RSQRT",e[e.SIN=16]="SIN",e[e.SINH=17]="SINH",e[e.SIGMOID=18]="SIGMOID",e[e.SQRT=19]="SQRT",e[e.SQUARE=20]="SQUARE",e[e.TANH=21]="TANH",e[e.TO_INT=22]="TO_INT"}(c||(c={}));function v(e,n){switch(e){case c.ABS:return"return abs(a);";case c.COS:return"return cos(a);";case c.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case c.CEIL:return"return ceil(a);";case c.ELU:return n?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case c.EXP:return"return exp(a);";case c.EXPM1:return"return exp(a) - 1.0;";case c.FLOOR:return"return floor(a);";case c.LINEAR:return"return a;";case c.LOG:return"if (a < 0.0) { return 1.0/0.0; }\n  return log(a);";case c.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case c.NEG:return"return -a;";case c.LEAKYRELU:return n?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case c.RELU:return n?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case c.RELU6:return n?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case c.RSQRT:return"return 1.0/sqrt(a);";case c.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case c.SIN:return"return sin(a);";case c.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case c.SQRT:return"return sqrt(a);";case c.SQUARE:return"return a * a;";case c.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case c.TO_INT:return"return f32(i32((a)));";default:throw new Error("BinaryType "+e+" is not implemented!")}}function g(e,n){if(void 0===n&&(n=!1),null===e)return null;if("linear"===e)return v(c.LINEAR);if("relu"===e)return v(c.RELU,n);if("elu"===e)return v(c.ELU,n);if("relu6"===e)return v(c.RELU6,n);if("prelu"===e)return m(d.PRELU,n);if("sigmoid"===e)return v(c.SIGMOID,n);if("leakyrelu"===e)return v(c.LEAKYRELU,n);throw new Error("Activation "+e+" has not been implemented for the WebGPU backend.")}function b(e,n){if(Math.max.apply(Math,l(e))>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");var t=e.length,r=e.map((function(e){return n+"["+e+"]"})),i=new Array(t-1);i[t-2]=r[t-1];for(var o=t-3;o>=0;--o)i[o]="("+i[o+1]+" * "+r[o+1]+")";return i}function k(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error("GPU for rank "+e+" is not yet supported")}function I(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error("Index "+e+" is not yet supported")}function x(e,n){return"float32"===e?n?"vec4<f32>":"f32":"int32"===e||"bool"===e?n?"vec4<i32>":"i32":e}function w(e,t,r,i){void 0===i&&(i=!1);var o=[];if(o.push("\n    let workGroupSizeX = "+r.workGroupSize[0]+"u;\n    let workGroupSizeY = "+r.workGroupSize[1]+"u;\n    let workGroupSizeZ = "+r.workGroupSize[2]+"u;\n\n    var<private> localId: vec3<u32>;\n    var<private> globalId: vec3<u32>;\n    var<private> numWorkgroups: vec3<u32>;\n\n    // Only used when the y/z dimension of workgroup size is 1.\n    fn getGlobalIndex() -> i32 {\n      if (numWorkgroups.y == 1u && numWorkgroups.z == 1u) {\n        return i32(globalId.x);\n      }\n\n      let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +\n          localId.y * workGroupSizeX + localId.x;\n      let workGroupID = (globalId - localId)/vec3<u32>(\n          workGroupSizeX, workGroupSizeY, workGroupSizeZ);\n\n      return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +\n        workGroupID.y * numWorkgroups.x + workGroupID.x) *\n        (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +\n        localInvocationIndex);\n    }\n  "),!0===i)return o.push("\n      struct Uniform {\n        size            : i32,\n        numChannels     : i32,\n        outShapeStrides : vec2<i32>,\n        dispatchSize    : vec3<u32>,\n      };\n\n      @group(0) @binding(0) var<storage, write> result: array<"+x(t.dtype,r.isVec4)+">;\n      @group(0) @binding(2) var<uniform> uniforms: Uniform;\n    "),[y,o.join("\n"),C(t.shape),r.getUserCode()].join("\n");var a=!1,u=!1,l="struct Uniforms { NAN : f32, ";r.variableNames.forEach((function(n,t){var r=k(e[t].shape.length);"vec5"!==r&&"vec6"!==r||(u=!0),(a||u)&&(l+="@align(16) "),a=u,l+=n.charAt(0).toLowerCase()+n.slice(1)+"Shape : "+r+", "}));var d=k(t.shape.length);u="vec5"===d||"vec6"===d,(a||u)&&(l+="@align(16) "),a=u,l+="outShape : "+d+", ";var p=k(t.shape.length-1);u="vec5"===p||"vec6"===p,(a||u)&&(l+="@align(16) "),a=u,l+="\n       outShapeStrides: "+p+", ",r.size&&(a&&(l+="@align(16) "),a=!1,l+="size : i32, "),r.uniforms&&(a&&(l+="@align(16) "),l+=r.uniforms),l+="};",o.push(l),r.atomic?o.push("\n    @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n  "):o.push("\n    @group(0) @binding(0) var<storage, write> result: array<"+x(t.dtype,r.isVec4)+">;\n  "),r.variableNames.forEach((function(n,t){o.push("\n    @group(0) @binding("+(1+t)+") var<storage, read> "+n+": array<"+(r.variableTypes?r.variableTypes[t]:x(e[t].dtype,r.isVec4))+">;\n      ")})),""!==l&&o.push("\n    @group(0) @binding("+(1+r.variableNames.length)+") var<uniform> uniforms: Uniforms;\n    ");var c=s(function(e,n){var t=n.x,r=n.y,i=void 0===r?[]:r,o=n.z,a=void 0===o?[]:o,u=e.length;if(t.length===u){return["fn getOutputCoords() -> "+k(u)+"{\n      let globalIndex = getGlobalIndex();\n      return getCoordsFromIndex(globalIndex);\n    }\n    ",u]}for(var s="",l=[t,i,a],d=0,p=0;p<l.length;p++){var c=l[p];if(0!==c.length)if(d+=c.length,1===c.length)s+="let d"+c[0]+" = i32(globalId["+p+"]);";else{var h=b(c,"uniforms.outShape");s+="var index"+p+" = i32(globalId["+p+"]);";for(var f=0;f<h.length;f++)s+="let d"+c[f]+" = index"+p+" / "+h[f]+";",f===h.length-1?s+="let d"+c[f+1]+" = index"+p+" - d"+c[f]+" * "+h[f]+";":s+="index"+p+" = index"+p+" - d"+c[f]+" * "+h[f]+";"}}var m=[];for(p=0;p<d;p++)m.push("d"+p);var v=k(d),g="fn getOutputCoords() -> "+v+" {\n    "+s+"\n  ";0===m.length?g+="return "+v+"(0); }":g+="return "+v+"("+m.join(",")+"); }";return[g,d]}(t.shape,r.dispatchLayout),2),h=c[0],f=c[1],m=[y,o.join("\n"),C(t.shape),h,S(t.shape.length)];if(r.atomic||m.push(function(e,n,t){var r,i=e.length,o=x(n,t);r=t?"fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {\n      result[flatIndex] = "+o+"(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {\n      result[flatIndex] = "+o+"(value);\n    }":"fn setOutputAtIndex(flatIndex : i32, value : f32) {\n      result[flatIndex] = "+o+"(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {\n      result[flatIndex] = "+o+"(value);\n    }";if(i>=2){var a=["d0","d1","d2","d3","d4","d5"].slice(0,i),u=k(i);r+=t?"\n      fn setOutputAtCoords("+a.map((function(e){return e+" : i32"})).join(", ")+", value : vec4<f32>) {\n        let flatIndex = getOutputIndexFromCoords("+u+"("+a.join(", ")+"));\n        setOutputAtIndex(flatIndex / 4, value);\n      }\n      fn setOutputAtCoordsI32("+a.map((function(e){return e+" : i32"})).join(", ")+", value : vec4<i32>) {\n        let flatIndex = getOutputIndexFromCoords("+u+"("+a.join(", ")+"));\n        setOutputAtIndexI32(flatIndex / 4, value);\n      }\n    ":"\n      fn setOutputAtCoords("+a.map((function(e){return e+" : i32"})).join(", ")+", value : f32) {\n        let flatIndex = getOutputIndexFromCoords("+u+"("+a.join(", ")+"));\n        setOutputAtIndex(flatIndex, value);\n      }\n      fn setOutputAtCoordsI32("+a.map((function(e){return e+" : i32"})).join(", ")+", value : i32) {\n        let flatIndex = getOutputIndexFromCoords("+u+"("+a.join(", ")+"));\n        setOutputAtIndexI32(flatIndex, value);\n      }\n    "}return r}(t.shape,t.dtype,r.isVec4)),f===t.shape.length){var v=e.map((function(e,i){return function(e,t,r,i){var o=function(e,n){var t=e.name,r=e.shape.length,i=k(r),o="get"+t.charAt(0).toUpperCase()+t.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,r),u=a.map((function(e){return e+" : i32"})).join(", ");if(r<1)return n?"\n        fn "+o+"() -> vec4<f32> {\n          return vec4<f32>("+t+"[0]);\n        }\n      ":"\n      fn "+o+"() ->f32 {\n        return f32("+t+"[0]);\n      }\n    ";var s="uniforms."+(t.charAt(0).toLowerCase()+t.slice(1))+"Shape",l=r+"D";0===r&&(l="1D");if(n)return"\n      fn "+o+"("+u+") -> vec4<f32> {\n        return vec4<f32>("+t+"[getIndexFromCoords"+l+"("+i+"("+a.join(",")+"),\n          "+s+") / 4]);\n      }\n      ";return"\n    fn "+o+"("+u+") -> f32 {\n      return f32("+t+"[getIndexFromCoords"+l+"("+i+"("+a.join(",")+"),\n        "+s+")]);\n    }\n   "}(e,r);e.shape.length<=t.length&&(o+=function(e,t,r,i){var o=e.name,a=o.charAt(0).toUpperCase()+o.slice(1),u="get"+a+"ByOutput",s=e.shape.length,l=t.length,d=k(l);if(n.util.arraysEqual(e.shape,t)&&i)return r?"\n        fn "+u+"Index(globalIndex : i32) -> vec4<f32> {\n          return vec4<f32>("+o+"[globalIndex]);\n        }\n\n        fn "+u+"Coords(coords : "+d+") -> vec4<f32> {\n          return vec4<f32>("+o+"["+(l>1?"getOutputIndexFromCoords(coords)":"coords")+" / 4]);\n        }\n        ":"\n      fn "+u+"Index(globalIndex : i32) -> f32 {\n        return f32("+o+"[globalIndex]);\n      }\n\n      fn "+u+"Coords(coords : "+d+") -> f32 {\n        return f32("+o+"["+(l>1?"getOutputIndexFromCoords(coords)":"coords")+"]);\n      }\n      ";var p=n.backend_util.getBroadcastDims(e.shape,t),c=l-s,h="";if(0===s)return r?"\n      fn "+u+"Index(globalIndex : i32) -> vec4<f32> {\n        return get"+a+"();\n      }\n\n      fn "+u+"Coords(coords : "+d+") -> vec4<f32> {\n        return get"+a+"();\n      }\n    ":"\n      fn "+u+"Index(globalIndex : i32) -> f32{\n        return get"+a+"();\n      }\n\n      fn "+u+"Coords(coords : "+d+") -> f32{\n        return get"+a+"();\n      }\n    ";h=l<2&&p.length>=1?"coords = 0;":p.map((function(e){return"coords."+I(e+c)+" = 0;"})).join("\n");var f="";if(l<2&&s>0)f="coords";else{if(l>1)f=k(s)+"("+e.shape.map((function(e,n){return"coords."+I(n+c)})).join(", ")+")";else f="coords"}var m="uniforms."+(o.charAt(0).toLowerCase()+o.slice(1))+"Shape",v=s+"D";if(r)return"\n      fn "+u+"Index(globalIndex : i32) -> vec4<f32> {\n        var coords = getCoordsFromIndex(globalIndex);\n        "+h+"\n        return "+o+"[getIndexFromCoords"+v+"("+f+", "+m+") / 4];\n      }\n\n      fn "+u+"Coords(coordsIn : "+d+") -> vec4<f32> {\n        var coords = coordsIn;\n        "+h+"\n        return "+o+"[getIndexFromCoords"+v+"("+f+", "+m+") / 4];\n      }\n    ";return"\n    fn "+u+"Index(globalIndex : i32) -> f32 {\n      var coords = getCoordsFromIndex(globalIndex);\n      "+h+"\n      return f32("+o+"[getIndexFromCoords"+v+"("+f+", "+m+")]);\n    }\n\n    fn "+u+"Coords(coordsIn : "+d+") -> f32 {\n      var coords = coordsIn;\n      "+h+"\n      return f32("+o+"[getIndexFromCoords"+v+"("+f+", "+m+")]);\n    }\n  "}(e,t,r,i));return o}(e,t.shape,r.variableTypes?"vec4<f32>"===r.variableTypes[i]:r.isVec4,r.dispatchLayout.x.length===t.shape.length)})).join("\n");m.push(v)}return m.push(r.getUserCode()),m.join("\n")}var y="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  fn idiv(a: i32, b: i32, sign: f32) -> i32 {\n    var res: i32 = a / b;\n    let mod: i32 = a % b;\n    if (sign < 0. && mod != 0) {\n      res = res - 1;\n    }\n    return res;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    return vec4<bool>(isnan(val[0]), isnan(val[1]), isnan(val[2]), isnan(val[3]));\n  }\n";function S(e){var t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:n.util.assert(!1,(function(){return"Unsupported "+e+"D shape"}))}return t}function C(e){var t=e.length;if(t<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";for(var r=n.util.computeStrides(e),i=k(t),o=[],a=0;a<t;a++)o.push("d"+a);return 1===r.length?"    fn getCoordsFromIndex(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;\n      return vec2<i32>(d0, d1);\n    }":"\n    fn getCoordsFromIndex(index : i32) -> "+i+" {\n      "+("var index2 = index;"+r.map((function(e,n){return"let "+o[n]+" = index2 / uniforms.outShapeStrides."+I(n)+"; "+(n===r.length-1?"let "+o[n+1]+" = index2 - "+o[n]+" * uniforms.outShapeStrides."+I(n):"index2 = index2 - "+o[n]+" * uniforms.outShapeStrides."+I(n))+";"})).join(""))+"\n      return "+i+"("+o.join(",")+");\n    }\n  "}var z=function(e){for(var n=1,t=0;t<e.length;t++)n*=e[t];return n};function _(e,n){if(e.length!==n.length)throw new Error("Cannot compute whether rank "+e.length+" tiles fit evenly into rank "+n.length+" shape - ranks must match.");return n.every((function(n,t){return n%e[t]==0}))}function G(e,n,t,r){void 0===t&&(t=[1,1,1]),void 0===r&&(r=[1,1,1]);var i=s([Math.ceil(z(e.x.map((function(e){return n[e]})))/(t[0]*r[0])),e.y?Math.ceil(z(e.y.map((function(e){return n[e]})))/(t[1]*r[1])):1,e.z?Math.ceil(z(e.z.map((function(e){return n[e]})))/(t[2]*r[2])):1],3);return[i[0],i[1],i[2]]}function A(e,n){var t=z(e.x.map((function(e){return n[e]}))),r=z(e.y.map((function(e){return n[e]})));return t<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function T(e,n,t){return 1===e?[32,1,1]:1===t?[1,32,1]:[8,8,1]}function R(e,n){var t=z(e.x.map((function(e){return n[e]}))),r=z(e.y.map((function(e){return n[e]})));return t<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function P(e){return{x:e.map((function(e,n){return n}))}}function N(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error("Unknown dtype "+e)}function B(e,n){if("float32"===n)return new Float32Array(e);if("int32"===n)return new Int32Array(e);if("bool"===n||"string"===n)return Uint8Array.from(new Int32Array(e));throw new Error("Unknown dtype "+n)}function L(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}var W={__proto__:null,tilesFitEvenlyIntoShape:_,computeDispatch:G,computeWorkGroupSizeForConv2d:A,computeWorkGroupSizeForMatMul:T,computeWorkPerThreadForConv2d:R,flatDispatchLayout:P,GPUBytesPerElement:N,ArrayBufferToTypedArray:B,isWebGPUSupported:L};function E(e,t,r,i,o){return void 0===o&&(o=4),n.util.assert(!(i%4!=0&&i%3!=0||4!==e[0]||3!==o&&4!==o),(function(){return"tileInner must be divisible by 4|3. ColPerThread must be 4.\n           innerElementSize must be 3|4."})),"\n  var<workgroup> mm_Asub : array<array<vec"+o+"<f32>, "+i/o+">, "+t+">;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, "+r/e[0]+">, "+i+">;\n\n  let RowPerThread = "+e[1]+";\n  let ColPerThread = "+e[0]+";\n  let InnerElementSize = "+o+";\n  let TileInner = "+i+";\n\n  \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n\n    let tileRow = "+(1===t?"0":"i32(localId.y) * RowPerThread")+";\n    let tileCol = i32(localId.x);\n\n    let globalRow = "+(1===t?"0":"i32(globalId.y) * RowPerThread")+";\n    let globalCol = i32(globalId.x);\n    let numTiles = (uniforms.dimInner - 1) / TileInner + 1;\n\n    var acc: array<vec4<f32>, RowPerThread>;\n    var BCached : array<vec4<f32>, 4>;\n\n    // Loop over shared dimension.\n    var globalColA = tileCol;\n    let RowPerThreadB = TileInner / i32(workGroupSizeY);\n    let tileRowB = i32(localId.y) * RowPerThreadB;\n    for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            mm_Asub[inputRow][inputCol] = mm_readA(globalRow + innerRow, globalColA, globalId);\n        }\n        globalColA = globalColA + TileInner / InnerElementSize;\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(t * TileInner + inputRow, globalCol, globalId);\n        }\n\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < TileInner / InnerElementSize; k = k + 1) {\n            BCached[0] = mm_Bsub[k * InnerElementSize][tileCol];\n            BCached[1] = mm_Bsub[k * InnerElementSize + 1][tileCol];\n            BCached[2] = mm_Bsub[k * InnerElementSize + 2][tileCol];\n            "+(3===o?"":"BCached[3] = mm_Bsub[k * InnerElementSize + 3][tileCol];")+"\n\n            for (var i = 0; i < RowPerThread; i = i + 1) {\n                let ACached = mm_Asub[tileRow + i][k];\n                acc[i] = BCached[0] * ACached.x + acc[i];\n                acc[i] = BCached[1] * ACached.y + acc[i];\n                acc[i] = BCached[2] * ACached.z + acc[i];\n                "+(3===o?"":"acc[i] = BCached[3] * ACached.w + acc[i];")+"\n            }\n        }\n\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        mm_write(globalRow + innerRow,\n                 globalCol,\n                 acc[innerRow], globalId);\n    }\n  }"}var O=function(){function e(e,n,t,r,i,o,a,u){var l;void 0===o&&(o=null),void 0===a&&(a=null),void 0===u&&(u=null),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[8,8,1],this.isVec4=!0,this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},1===n[1]?this.elementsPerThread=[4,1,1]:this.elementsPerThread=[4,4,1],this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread);var d=null!=o,p=null!=u;d&&this.variableNames.push("bias"),p&&this.variableNames.push("preluActivationWeights"),this.tileAOuter=1===n[1]?1:this.workGroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workGroupSize[0]*this.elementsPerThread[0],this.tileInner=this.tileBOuter,this.aShape=e,this.addBias=d,this.activation=a,this.hasPreluActivationWeights=p,this.batchAEqualOne=r,this.batchBEqualOne=i,l=s(this.getShapeFit(),2),this.fitA=l[0],this.fitB=l[1],this.shaderKey="matMulPackedVec4_"+this.activation+"_"+this.fitA+"_"+this.fitB+"_"+this.elementsPerThread+"_"+this.batchAEqualOne+"_"+this.batchBEqualOne}return e.prototype.getShapeFit=function(){var e=this.aShape[2],n=this.outputShape[2],t=[this.outputShape[0],e,n],r=[this.tileAOuter,this.tileInner],i=[this.tileInner,this.tileBOuter];return[_(r,this.aShape.slice(1)),_(i,t.slice(1))]},e.prototype.getUserCode=function(){var e=this.fitA?"return A[batch * batchASize + row * uniforms.dimInner / 4 + col]":"if (coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {\n            return A[batch * batchASize + row * uniforms.dimInner / 4 + col];\n        }\n        return vec4<f32>(0.0)",n=this.fitB?"return B[batch * batchBSize + row * uniforms.dimBOuter / 4 + col]":"if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {\n             return B[batch * batchBSize + row * uniforms.dimBOuter / 4 + col];\n        }\n        return vec4<f32>(0.0)",t="",r="";if(this.activation){var i=g(this.activation,this.isVec4);t=this.hasPreluActivationWeights?"fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {\n                  let b = getPreluActivationWeightsByOutputCoords(outCoord);\n                  "+i+"\n                }":"\n            fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {\n              "+i+"\n            }",r="value = activation(value, outCoord);"}var o=this.addBias?"value = value + getBiasByOutputCoords(outCoord);":"";return"\n      "+t+"\n      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {\n        "+(this.batchAEqualOne?"\n          let batchASize = 0;\n          let batch = 0;\n        ":"\n          let batchASize = uniforms.aShape[1] * uniforms.aShape[2] / 4;\n          let batch = i32(globalId.z);\n        ")+"\n\n        "+e+";\n      }\n\n      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {\n        "+(this.batchBEqualOne?"\n          let batchBSize = 0;\n          let batch = 0;\n          ":"\n          let batchBSize = uniforms.bShape[1] * uniforms.bShape[2] / 4;\n          let batch = i32(globalId.z);\n       ")+"\n        "+n+";\n      }\n\n      fn mm_write(row : i32, col : i32, valueIn : vec4<f32>, globalId : vec3<u32>) {\n        if (row < uniforms.aShape[1] && col * 4 < uniforms.bShape[2])\n        {\n          var value = valueIn;\n          let batch = i32(globalId.z);\n          let outCoord = vec3<i32>(batch, row, col * 4);\n          "+o+"\n          "+r+"\n          setOutputAtCoords(outCoord[0], outCoord[1], outCoord[2], value);\n        }\n      }\n      "+E(this.elementsPerThread,this.tileAOuter,this.tileBOuter,this.tileInner)+"\n    "},e}();function F(e,n){var t=n[1]*e[1],r=n[0]*e[0],i=t>r?t:r;return"\n    var<workgroup> mm_Asub : array<array<f32, "+i+">, "+t+">;\n    var<workgroup> mm_Bsub : array<array<f32, "+r+">, "+i+">;\n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let tileRow = i32(localId.y) * "+e[1]+";\n      let tileCol = i32(localId.x) * "+e[0]+";\n\n      let globalRow = i32(globalId.y) * "+e[1]+";\n      let globalCol = i32(globalId.x) * "+e[0]+";\n\n      let numTiles = (uniforms.dimInner - 1) / "+i+" + 1;\n\n      var acc : array<array<f32, "+e[0]+">, "+e[1]+">;\n      var ACached : f32;\n      var BCached : array<f32, "+e[0]+">;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < "+e[1]+"; innerRow = innerRow + 1) {\n        for (var innerCol = 0; innerCol < "+e[0]+"; innerCol = innerCol + 1) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n\n      let ColPerThreadA = "+i+" / "+n[0]+";\n      let tileColA = i32(localId.x) * ColPerThreadA;\n      let RowPerThreadB = "+i+" / "+n[1]+";\n      let tileRowB = i32(localId.y) * RowPerThreadB;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < "+e[1]+"; innerRow = innerRow + 1) {\n          for (var innerCol = 0; innerCol < ColPerThreadA; innerCol = innerCol + 1) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileColA + innerCol;\n\n            mm_Asub[inputRow][inputCol] = mm_readA(\n                globalRow + innerRow,\n                t * "+i+" + inputCol, globalId);\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {\n          for (var innerCol = 0; innerCol < "+e[0]+"; innerCol = innerCol + 1) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol + innerCol;\n\n            mm_Bsub[inputRow][inputCol] = mm_readB(\n              t * "+i+" + inputRow,\n              globalCol + innerCol, globalId);\n          }\n        }\n\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < "+i+"; k = k + 1) {\n          for (var inner = 0; inner < "+e[0]+"; inner = inner + 1) {\n            BCached[inner] = mm_Bsub[k][tileCol + inner];\n          }\n\n          for (var innerRow = 0; innerRow < "+e[1]+"; innerRow = innerRow + 1) {\n            ACached = mm_Asub[tileRow + innerRow][k];\n            for (var innerCol = 0; innerCol < "+e[0]+"; innerCol = innerCol + 1) {\n              acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n            }\n          }\n        }\n\n        workgroupBarrier();\n      }\n\n      for (var innerRow = 0; innerRow < "+e[1]+"; innerRow = innerRow + 1) {\n        for (var innerCol = 0; innerCol < "+e[0]+"; innerCol = innerCol + 1) {\n\n          if ((globalCol + innerCol) < uniforms.dimBOuter &&\n              (globalRow + innerRow) < uniforms.dimAOuter) {\n            mm_write(globalRow + innerRow,\n                     globalCol + innerCol,\n                     acc[innerRow][innerCol], globalId);\n          }\n        }\n      }\n    }\n  "}var U=function(){function e(e,t,r,i,o,a,u,l,d,p){var c;void 0===a&&(a=!1),void 0===u&&(u=!1),void 0===l&&(l=null),void 0===d&&(d=null),void 0===p&&(p=null),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[16,16,1],this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};var h=a?e[1]:e[2];this.workGroupSize=T(t[1],0,t[2]),1!==t[1]&&1!==t[2]||(r=1),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,[r,r,1]),n.util.arraysEqual(this.dispatch,[1,1,1])&&(r=1,this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,[r,r,1]));var f=null!=l,m=null!=p;f&&this.variableNames.push("bias"),m&&this.variableNames.push("preluActivationWeights"),this.workPerThread=r,this.aShape=e,this.transposeA=a,this.transposeB=u,this.addBias=f,this.activation=d,this.hasPreluActivationWeights=m,this.batchAEqualOne=i,this.batchBEqualOne=o;var v=this.outputShape[2],g=this.transposeB?[this.outputShape[0],v,h]:[this.outputShape[0],h,v];c=s(this.getShapeFit(g),2),this.fitA=c[0],this.fitB=c[1],this.shaderKey="matMulPacked_"+this.workPerThread+"_"+a+"_"+u+"_"+this.activation+"_"+this.fitA+"_"+this.fitB+"_"+(this.outputShape[1]>1)+"_"+this.batchAEqualOne+"_"+this.batchBEqualOne}return e.prototype.getShapeFit=function(e){var t=this.workGroupSize[1]*this.workPerThread,r=this.workGroupSize[0]*this.workPerThread,i=t>r?t:r;1===this.outputShape[1]&&(i*=4),n.util.assert(i%this.workGroupSize[0]==0&&i%this.workGroupSize[1]==0,(function(){return"tileInner must be multiple of workgroupsize.x and workgroupsize.y"}));var o=[i,r];return[_([t,i],this.aShape.slice(1)),_(o,e.slice(1))]},e.prototype.getUserCode=function(){var e,n;e=!1===this.transposeA?this.fitA?"return A[batch * batchASize + row * uniforms.dimInner + col];":"if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {\n             return A[batch * batchASize + row * uniforms.dimInner + col];\n           }\n           return 0.0;":this.fitA?"return A[batch * batchASize + col * uniforms.dimAOuter + row];":"if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {\n             return A[batch* batchASize + col * uniforms.dimAOuter + row];\n           }\n           return 0.0;",n=!1===this.transposeB?this.fitB?"return B[batch * batchBSize + row * uniforms.dimBOuter + col];":"if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {\n             return B[batch * batchBSize + row * uniforms.dimBOuter + col];\n           }\n           return 0.0;":this.fitB?"return B[batch * batchBSize + col * uniforms.dimInner + row];":"if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {\n             return B[batch * batchBSize + col * uniforms.dimInner + row];\n           }\n           return 0.0;";var t="",r="";if(this.activation){var i=g(this.activation,!1);t=this.hasPreluActivationWeights?"fn activation(a : f32, outCoord : vec3<i32>) -> f32 {\n               let b = getPreluActivationWeightsByOutputCoords(outCoord);\n               "+i+"\n            }":"\n              fn activation(a : f32, outCoord : vec3<i32>) -> f32 {\n                "+i+"\n              }\n            ",r="value = activation(value, outCoord);"}var o,a=this.addBias?"value = value + getBiasByOutputCoords(outCoord);":"";return"\n      "+t+"\n\n      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {\n        "+(this.batchAEqualOne?"\n        let batch = 0;\n        let batchASize = 0;\n        ":"\n        let batch = i32(globalId.z);\n        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];\n        ")+"\n        "+e+"\n      }\n\n      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {\n        "+(this.batchBEqualOne?"\n        let batch = 0;\n        let batchBSize = 0;\n        ":"\n        let batch = i32(globalId.z);\n        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];\n        ")+"\n        "+n+"\n      }\n\n      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {\n        var value = valueIn;\n        let batch = i32(globalId.z);\n        let outCoord = vec3<i32>(batch, row, col);\n        "+a+"\n        "+r+"\n        setOutputAtCoords(batch, row, col, value);\n      }\n      "+(this.outputShape[1]>1?F([this.workPerThread,this.workPerThread,1],this.workGroupSize):"\n    let TileSize = "+4*(o=this.workGroupSize)[0]+";\n    var<workgroup> mm_Asub : array<vec4<f32>, "+o[0]+">;\n\n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;\n\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        let colA = t * TileSize + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(mm_readA(globalRow, colA, globalId),\n                                mm_readA(globalRow, colA + 1, globalId),\n                                mm_readA(globalRow, colA + 2, globalId),\n                                mm_readA(globalRow, colA + 3, globalId));\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < TileSize / 4; k = k + 1) {\n          let rowB = t * TileSize + k * 4;\n          let BCached = vec4<f32>(mm_readB(rowB, globalCol, globalId),\n                              mm_readB(rowB + 1, globalCol, globalId),\n                              mm_readB(rowB + 2, globalCol, globalId),\n                              mm_readB(rowB + 3, globalCol, globalId));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {\n        mm_write(globalRow, globalCol, acc, globalId);\n      }\n    }\n  ")+"\n    "},e}();var D=function(){function e(e,n,t,r,i,o,a,u){void 0===r&&(r=!1),void 0===i&&(i=!1),void 0===o&&(o=null),void 0===a&&(a=null),void 0===u&&(u=null),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize);var s=null!=o,l=null!=u;s&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=s,this.activation=a,this.hasPreluActivationWeights=l,this.batchAEqualOne=n,this.batchBEqualOne=t,this.shaderKey="matMulReduce_"+this.activation+"_"+r+"_"+i+"_"+this.batchAEqualOne+"_"+this.batchBEqualOne}return e.prototype.getUserCode=function(){var e,n;e=!1===this.transposeA?"return f32(A[batch * batchASize + row * uniforms.dimInner + col]);":"return f32(A[batch * batchASize + col * uniforms.dimAOuter + row]);",n=!1===this.transposeB?"return f32(B[batch * batchBSize + row * uniforms.dimBOuter + col]);":"return f32(B[batch * batchBSize + col * uniforms.dimInner + row]);";var t="",r="";if(this.activation){var i=g(this.activation,!1);t=this.hasPreluActivationWeights?"fn activation(a : f32, outCoord : vec3<i32>) -> f32 {\n               let b = getPreluActivationWeightsByOutputCoords(outCoord);\n               "+i+"\n            }":"\n              fn activation(a : f32, outCoord : vec3<i32>) -> f32 {\n                "+i+"\n              }\n            ",r="value = activation(value, outCoord);"}var o=this.addBias?"value = value + getBiasByOutputCoords(outCoord);":"";return"\n      "+t+"\n\n      fn mm_readA(batchIn: i32, row : i32, col : i32) -> f32 {\n        "+(this.batchAEqualOne?"\n          let batchASize = 0;\n          let batch = 0;\n          ":"\n          let batchASize = uniforms.aShape[1] * uniforms.aShape[2];\n          let batch = batchIn;\n          ")+"\n        "+e+"\n      }\n\n      fn mm_readB(batchIn: i32, row : i32, col : i32) -> f32 {\n        "+(this.batchBEqualOne?"\n          let batch = 0;\n          let batchBSize = 0;\n          ":"\n          let batch = batchIn;\n          let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];\n          ")+"\n        "+n+"\n      }\n\n      fn mm_write(batch: i32, row : i32, col : i32, valueIn : f32) {\n        var value = valueIn;\n        let outCoord = vec3<i32>(batch, row, col);\n        "+o+"\n        "+r+"\n        setOutputAtCoords(batch, row, col, value);\n      }\n      \n    var<workgroup> sumValues : array<f32, workGroupSizeX>;\n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + i32(workGroupSizeX)) {\n        let dataA = mm_readA(batch, row, k);\n        let dataB = mm_readB(batch, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = workGroupSizeX / 2u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  \n    "},e}();var M=function(){function e(e,t,r,i,o,a){void 0===i&&(i=null),void 0===o&&(o=null),void 0===a&&(a=null),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[8,16,1],n.util.assert(e[1]<=16||t[2]<=16,(function(){return"This program can be only used when A width or B Height are small"})),this.outputShape=r,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(r[2]/this.workGroupSize[0]),Math.ceil(2*r[1]/this.workGroupSize[1]),r[0]];var u=null!=i;u&&this.variableNames.push("bias");var s=null!=a;s&&this.variableNames.push("preluActivationWeights"),this.addBias=u,this.activation=o,this.hasPreluActivationWeights=s,this.batchAEqualOne=1===e[0],this.batchBEqualOne=1===t[0],this.shaderKey="matMulSmallOutputSize_"+this.activation+"_"+this.batchAEqualOne+"_"+this.batchBEqualOne}return e.prototype.getUserCode=function(){var e="",n="";if(this.activation){var t=g(this.activation,!1);e=this.hasPreluActivationWeights?"fn activation(a : f32, outCoord : vec3<i32>) -> f32 {\n            let b = getPreluActivationWeightsByOutputCoords(outCoord);\n            "+t+"\n            }":"fn activation(a : f32, outCoord : vec3<i32>) -> f32 {\n            "+t+"\n        }",n="value = activation(value, outCoord);"}var r,i,o,a,u=this.addBias?"value = value + getBiasByOutputCoords(outCoord);":"";return"\n      "+e+"\n\n      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {\n        "+(this.batchAEqualOne?"\n          let batch = 0;\n          let batchASize = 0;\n          ":"\n          let batchASize = uniforms.aShape[1] * uniforms.aShape[2];\n          let batch = i32(globalId.z);\n          ")+"\n        if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {\n          return A[batch * batchASize + row * uniforms.dimInner + col];\n        }\n        return 0.0;\n      }\n      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {\n        "+(this.batchBEqualOne?"\n          let batch = 0;\n          let batchBSize = 0;\n          ":"\n          let batch = i32(globalId.z);\n          let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];\n          ")+"\n        if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {\n           return B[batch * batchBSize + row * uniforms.dimBOuter + col];\n         }\n         return 0.0;\n      }\n      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {\n        if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimBOuter))) {\n          let batch = i32(globalId.z);\n          let outCoord = vec3<i32>(batch, row, col);\n          var value = valueIn;\n          "+u+"\n          "+n+"\n          setOutputAtCoords(batch, row, col, value);\n        }\n      }\n      "+(r=this.workGroupSize,i=r[1]/2,o=r[0],"\n  var<workgroup> mm_Asub1 : array<array<f32, "+(a=i>o?i:o)+">, "+i+">;\n  var<workgroup> mm_Bsub1 : array<array<f32, "+o+">, "+a+">;\n  var<workgroup> mm_Asub2 : array<array<f32, "+a+">, "+i+">;\n  var<workgroup> mm_Bsub2 : array<array<f32, "+o+">, "+a+">;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Introduces two shared memory buffers, some logical threads could handle\n  // arithmetic operations and others handle IO operations between barrier api,\n  // makes ALUs and load/store units work simultaneously, could improves\n  // the performance.\n  \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / "+a+" + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = tileRow;\n    for (var t = 0; t < numTiles; t = t + 1) {\n      if (t == 0) {\n        if (tileRow < "+i+") {\n          // Load one tile of A and B into local memory.\n          // globalRow is always greater than or equal tileRow.\n          mm_Asub1[tileRow][tileCol] =\n              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);\n          globalColA = globalColA + "+a+";\n          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);\n          globalRowB = globalRowB + "+a+";\n        }\n      } else {\n        if (tileRow < "+i+") {\n          // Load one tile of A and B into local memory.\n          // globalRow is always greater than or equal tileRow.\n          mm_Asub1[tileRow][tileCol] =\n              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);\n          globalColA = globalColA + "+a+";\n          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);\n          globalRowB = globalRowB + "+a+";\n        } else {\n          // Compute acc values for a single thread.\n          for (var k = 0; k < "+a+"; k = k + 1) {\n            let subRow = tileRow - "+i+";\n            if (subRow < 0) {\n              continue;\n            }\n            acc = acc + mm_Asub2[subRow][k] * mm_Bsub2[k][tileCol];\n          }\n        }\n      }\n      workgroupBarrier();\n      if (t != 0) {\n        t = t + 1;\n      }\n\n      if (t < numTiles) {\n        if (tileRow < "+i+") {\n          // Load one tile of A and B into local memory.\n          // globalRow is always greater than or equal tileRow.\n          mm_Asub2[tileRow][tileCol] =\n              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);\n          globalColA = globalColA + "+a+";\n          mm_Bsub2[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);\n          globalRowB = globalRowB + "+a+";\n        } else {\n          // Compute acc values for a single thread.\n          for (var k = 0; k < "+a+"; k = k + 1) {\n            let subRow = tileRow - "+i+";\n            if (subRow < 0) {\n              continue;\n            }\n            acc = acc + mm_Asub1[subRow][k] * mm_Bsub1[k][tileCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    let writeCol = (globalRow - tileRow) / 2 + tileRow - "+i+";\n    if (tileRow >= "+i+" && writeCol >= 0) {\n      mm_write(writeCol, globalCol, acc, globalId);\n    }\n  }\n  \n    ")},e}();function V(e){var t=e.inputs,r=e.attrs,i=t.x,o=r.shape,a=n.util.sizeFromShape(i.shape),u=n.util.inferFromImplicitShape(o,a),s=n.util.sizeFromShape(u);return n.util.assert(a===s,(function(){return"The new shape ("+u+") has "+s+" elements and the old shape ("+i.shape+") has "+a+" elements. The new shape and old shape must have the same number of elements."})),e.backend.incRef(i.dataId),{dataId:i.dataId,shape:u,dtype:i.dtype}}var X={kernelName:n.Reshape,backendName:"webgpu",kernelFunc:V};function H(e){var t,r,i=e.a,o=e.b,a=e.transposeA,s=e.transposeB,l=e.backend,d=e.bias,p=void 0===d?null:d,c=e.preluActivationWeights,h=void 0===c?null:c,f=e.leakyreluAlpha,m=void 0===f?0:f,v=e.activation,g=void 0===v?null:v,b=i.shape.length,k=o.shape.length,I=a?i.shape[b-2]:i.shape[b-1],x=s?o.shape[k-1]:o.shape[k-2],w=a?i.shape[b-1]:i.shape[b-2],y=s?o.shape[k-2]:o.shape[k-1],S=i.shape.slice(0,-2),C=o.shape.slice(0,-2),z=n.util.sizeFromShape(S),_=n.util.sizeFromShape(C),G=n.broadcast_util.assertAndGetBroadcastShape(i.shape.slice(0,-2),o.shape.slice(0,-2)).concat([w,y]);n.util.assert(I===x,(function(){return"Error in matMul: inner shapes ("+I+") and ("+x+") of Tensors with shapes "+i.shape+" and "+o.shape+" and transposeA="+a+" and transposeB="+s+" must match."}));var A,T=a?[z,I,w]:[z,w,I],R=s?[_,y,x]:[_,x,y],P=V({inputs:{x:i},backend:l,attrs:{shape:T}}),N=V({inputs:{x:o},backend:l,attrs:{shape:R}}),B=[P,N],L=Math.max(z,_),W=1===z,E=1===_,F=I%4==0&&y%4==0&&!a&&!s;A=w*y<=32?new D([L,w,y],W,E,a,s,p,g,h):a||s||!(w<=16&&(y<=512||x>=2*y)||y<=16&&(w<=512||I>=2*w))?F?new O(T,[L,w,y],n.env().get("WEBGPU_MATMUL_WORK_PER_THREAD"),W,E,p,g,h):new U(T,[L,w,y],n.env().get("WEBGPU_MATMUL_WORK_PER_THREAD"),W,E,a,s,p,g,h):new M(T,R,[L,w,y],p,g,h);var X=[P,N];p&&X.push(p),h&&X.push(h);var H=[{type:"int32",data:[w]},{type:"int32",data:[y]},{type:"int32",data:[I]}];"leakyrelu"===g&&(H.push({type:"float32",data:[m]}),A.uniforms+=" alpha : f32,");var Y=l.runWebGPUProgram(A,X,i.dtype,H),q=V({inputs:{x:Y},backend:l,attrs:{shape:G}});B.push(Y);try{for(var j=u(B),K=j.next();!K.done;K=j.next()){var Q=K.value;l.disposeData(Q.dataId)}}catch(e){t={error:e}}finally{try{K&&!K.done&&(r=j.return)&&r.call(j)}finally{if(t)throw t.error}}return q}var Y={kernelName:n._FusedMatMul,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,i=n.a,o=n.b,a=n.bias,u=n.preluActivationWeights,s=r.transposeA,l=r.transposeB,d=r.activation;return H({a:i,b:o,transposeA:s,transposeB:l,backend:t,bias:a,preluActivationWeights:u,leakyreluAlpha:r.leakyreluAlpha,activation:d})}},q=function(){function e(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=n.backend_util.assertAndGetBroadcastShape(t,r),this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="binaryOpComplex_"+e,this.op=e}return e.prototype.getUserCode=function(){return"\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        "+m(this.op,!1)+"\n      }\n\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    "},e}(),j=function(){function e(e,t,r,i){this.variableNames=["A","B"],this.size=!0;this.workGroupSize=[256,1,1],this.outputShape=n.backend_util.assertAndGetBroadcastShape(t,r),this.dispatchLayout=P(this.outputShape),this.lastDimensionSize=i?r[0]:t[0],this.lastDimensionSize<256?this.workPerThread=1:this.lastDimensionSize<512?this.workPerThread=2:this.workPerThread=4,this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.useSharedMemoryWithB=i,this.op=e,this.shaderKey="binaryShared_"+e+"_"+this.lastDimensionSize+"_"+this.useSharedMemoryWithB}return e.prototype.getUserCode=function(){var e=this.lastDimensionSize>1?"coords["+(this.outputShape.length-1)+"]":"0",n=this.useSharedMemoryWithB?"let a = getAByOutputCoords(coords);\n         let b = sharedBuf["+e+"];":"let a = sharedBuf["+e+"];\n         let b = getBByOutputCoords(coords);";return"\n        fn binaryOperation(a : f32, b : f32) -> f32 {\n          "+m(this.op,!1)+"\n        }\n        var<workgroup> sharedBuf : array<f32, "+this.lastDimensionSize+">;\n        \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n\n          // Fill in the shared memory buffer. Here we need a loop to make sure\n          // that all data in A|B are uploaded when |sharedMemorySize| is larger\n          // than work group size.\n          for(var localIndex = i32(localId.x); localIndex < "+this.lastDimensionSize+"; localIndex = localIndex + "+this.workGroupSize[0]+") {\n            sharedBuf[localIndex] = f32("+(this.useSharedMemoryWithB?"B":"A")+"[localIndex]);\n          }\n          workgroupBarrier();\n\n          for(var i = 0; i < "+this.workPerThread+"; i = i + 1) {\n            let flatIndex = index * "+this.workPerThread+" + i;\n            if(flatIndex < uniforms.size) {\n              let coords = getCoordsFromIndex(flatIndex);\n\n              "+n+"\n              setOutputAtIndex(flatIndex, binaryOperation(a, b));\n            }\n          }\n        }\n        "},e}(),K=function(){function e(e,t,r){this.variableNames=["A","B"],this.workPerThread=4,this.isVec4=!0,this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=n.backend_util.assertAndGetBroadcastShape(t,r),this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.op=e,this.shaderKey="binaryVec4_"+e}return e.prototype.getUserCode=function(){return"\n      fn binaryOperation(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {\n        "+m(this.op,this.isVec4)+"\n      }\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          let b = getBByOutputIndex(index);\n          setOutputAtIndex(index, binaryOperation(a, b));\n        }\n      }\n    "},e}(),Q=function(){function e(e,t,r){this.variableNames=["A","B"],this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=n.backend_util.assertAndGetBroadcastShape(t,r),this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="binary_"+e,this.op=e}return e.prototype.getUserCode=function(){return"\n      fn binaryOperation(a : f32, b : f32) -> f32 {\n        "+m(this.op,!1)+"\n      }\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          let b = getBByOutputIndex(index);\n          setOutputAtIndex(index, binaryOperation(a, b));\n        }\n      }\n      "},e}();function Z(e,t,r){if(n.util.arraysEqual(t,r)&&n.util.sizeFromShape(t)%4==0)return new K(e,t,r);var i=1===t.length&&r.length>1&&t[0]<1024,o=1===r.length&&t.length>1&&r[0]<1024;return i||o?new j(e,t,r,o):new Q(e,t,r)}function J(e){var n=e.inputs.x;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var $={kernelName:n.Identity,backendName:"webgpu",kernelFunc:J};function ee(e){var n=e.inputs,t=e.backend,r=n.real,i=n.imag,o=t.makeTensorInfo(r.shape,"complex64"),a=t.tensorMap.get(o.dataId),u=J({inputs:{x:r},backend:t}),s=J({inputs:{x:i},backend:t});return a.complexTensorInfos={real:u,imag:s},o}var ne={kernelName:n.Complex,backendName:"webgpu",kernelFunc:ee},te=function(){function e(e,n){this.variableNames=["A"],this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.op=n,this.shaderKey="unary_"+n}return e.prototype.getUserCode=function(){return"\n      fn unaryOperation(a : f32) -> f32 {\n        "+v(this.op,!1)+"\n      }\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      "},e}();function re(e){var n=e.opType,t=e.cpuKernelImpl,r=e.dtype;return function(e){var i=e.inputs,o=e.backend,a=i.x,u=o,s=r||a.dtype;if(u.shouldExecuteOnCPU([a])&&null!=t){var l=u.tensorMap.get(a.dataId),d=t(l.values,s);return u.makeTensorInfo(a.shape,s,d)}var p=new te(a.shape,n);return u.runWebGPUProgram(p,[a],s)}}function ie(e){var t=e.opSnippet,r=e.cpuKernelImpl,i=e.supportsComplex,o=void 0!==i&&i,a=e.dtype;return function(e){var i,u=e.inputs,l=e.backend,p=u.a,c=u.b,h=l;if(o&&"complex64"===p.dtype){var f=h.tensorMap.get(p.dataId),m=h.tensorMap.get(c.dataId),v=void 0,g=void 0;if(t!==d.MUL)v=(i=s([[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map((function(e){var r=s(e,2),i=r[0],o=r[1],a={dataId:i.dataId,dtype:i.dtype,shape:p.shape},u={dataId:o.dataId,dtype:o.dtype,shape:c.shape},l=Z(t,p.shape,c.shape);return h.runWebGPUProgram(l,[a,u],n.upcastType(i.dtype,o.dtype))})),2))[0],g=i[1];else{var b=new q(d.COMPLEX_MULTIPLY_REAL,p.shape,c.shape),k=new q(d.COMPLEX_MULTIPLY_IMAG,p.shape,c.shape),I=[{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:p.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:p.shape},{dataId:m.complexTensorInfos.real.dataId,dtype:m.complexTensorInfos.real.dtype,shape:c.shape},{dataId:m.complexTensorInfos.imag.dataId,dtype:m.complexTensorInfos.imag.dtype,shape:c.shape}];v=h.runWebGPUProgram(b,I,"float32"),g=h.runWebGPUProgram(k,I,"float32")}var x=ee({inputs:{real:v,imag:g},backend:h});return h.disposeData(v.dataId),h.disposeData(g.dataId),x}var w=a||n.upcastType(p.dtype,c.dtype);if(("string"===p.dtype||"string"===c.dtype||h.shouldExecuteOnCPU([p,c]))&&null!=r){f=h.tensorMap.get(p.dataId).values,m=h.tensorMap.get(c.dataId).values;var y="string"===p.dtype?n.backend_util.fromUint8ToStringArray(f):f,S="string"===p.dtype?n.backend_util.fromUint8ToStringArray(m):m,C=s(r(p.shape,c.shape,y,S,w),2),z=C[0],_=C[1];return h.makeTensorInfo(_,w,z)}var G=Z(t,p.shape,c.shape);return h.runWebGPUProgram(G,[p,c],w)}}function oe(e){return function(t,r,i,o,a){var u=n.backend_util.assertAndGetBroadcastShape(t,r),s=u.length,l=n.util.computeStrides(u),d=n.util.sizeFromShape(u),p=n.util.getTypedArrayFromDType(a,d),c=t.length,h=r.length,f=n.util.computeStrides(t),m=n.util.computeStrides(r),v=n.backend_util.getBroadcastDims(t,u),g=n.backend_util.getBroadcastDims(r,u);if(v.length+g.length===0)for(var b=0;b<p.length;++b)p[b]=e(i[b%i.length],o[b%o.length]);else{var k=function(t){var r=n.util.indexToLoc(t,s,l),a=r.slice(-c);v.forEach((function(e){return a[e]=0}));var u=n.util.locToIndex(a,c,f),d=r.slice(-h);g.forEach((function(e){return d[e]=0}));var b=n.util.locToIndex(d,h,m);p[t]=e(i[u],o[b])};for(b=0;b<p.length;++b)k(b)}return[p,u]}}var ae=oe((function(e,n){return e+n}));function ue(e){return function(t,r,i){for(var o=n.util.getTypedArrayFromDType(r,t.length),a=0;a<t.length;++a)o[a]=e(t[a],i);return o}}var se=ue((function(e){return Math.ceil(e)}));var le=oe((function(e,n){return e===n?1:0})),de=ue((function(e){return Math.exp(e)})),pe=ue((function(e){return Math.expm1(e)})),ce=ue((function(e){return Math.floor(e)}));var he=oe((function(e,n){return e>n?1:0})),fe=oe((function(e,n){return e>=n?1:0})),me=oe((function(e,n){return e<n?1:0})),ve=oe((function(e,n){return e<=n?1:0})),ge=ue((function(e){return Math.log(e)}));var be=oe((function(e,n){return Math.max(e,n)})),ke=oe((function(e,n){return Math.min(e,n)})),Ie=oe((function(e,n){return e*n}));var xe=oe((function(e,n){return e!==n?1:0}));var we=ue((function(e){return 1/Math.sqrt(e)}));var ye=function(){function e(e,t,r,i,o,a){this.separator=n.util.encodeString(e),this.nGramWidths=t,this.leftPad=n.util.encodeString(r),this.rightPad=n.util.encodeString(i),this.padWidth=o,this.preserveShort=a}return e.prototype.getPadWidth=function(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)},e.prototype.getNumNGrams=function(e,n){var t=this.getPadWidth(n);return Math.max(0,e+2*t-n+1)},e.prototype.createNGrams=function(e,n,t,r,i,o){for(var a=function(a){var s=u.getPadWidth(o),l=Math.max(0,s-a),d=Math.max(0,s-(i-(a+1))),p=o-(l+d),c=n+(l>0?0:a-s),h=0;h+=l*u.leftPad.length;for(var f=0;f<p;++f)h+=e[c+f].length;h+=d*u.rightPad.length,h+=(l+d+p-1)*u.separator.length,t[r+a]=new Uint8Array(h);var m=t[r+a],v=0,g=function(e){return e.forEach((function(e){return m[v++]=e}))};for(f=0;f<l;++f)g(u.leftPad),g(u.separator);for(f=0;f<p-1;++f)g(e[c+f]),g(u.separator);if(p>0){g(e[c+p-1]);for(f=0;f<d;++f)g(u.separator),g(u.rightPad)}else{for(f=0;f<d-1;++f)g(u.rightPad),g(u.separator);g(u.rightPad)}},u=this,s=0;s<i;++s)a(s)},e.prototype.compute=function(e,t){var r=this,i=e.length,o=t.length;if(o>0){var a=t[0];if(0!==a)throw new Error("First split value must be 0, got "+a);for(var u=1;u<o;++u){var s=t[u]>=a;if(!(s=s&&t[u]<=i))throw new Error("Invalid split value "+t[u]+", must be in ["+a+", "+i+"]");a=t[u]}if(a!==i)throw new Error("Last split value must be data size. Expected "+i+", got "+a)}var l=o-1,d=n.util.getArrayFromDType("int32",o);if(0===i||0===o){var p=new Array(i);for(u=0;u<=l;++u)d[u]=0;return[p,d]}d[0]=0;var c=function(e){var n=t[e]-t[e-1],i=0;h.nGramWidths.forEach((function(e){i+=r.getNumNGrams(n,e)})),h.preserveShort&&n>0&&0===i&&(i=1),d[e]=d[e-1]+i},h=this;for(u=1;u<=l;++u)c(u);var f=new Array(d[l]),m=function(n){var i=t[n],o=d[n];if(v.nGramWidths.forEach((function(a){var u=t[n+1]-t[n],s=r.getNumNGrams(u,a);r.createNGrams(e,i,f,o,s,a),o+=s})),v.preserveShort&&o===d[n]){var a=t[n+1]-t[n];if(0===a)return"continue";var u=a+2*v.padWidth;v.createNGrams(e,i,f,o,1,u)}},v=this;for(u=0;u<l;++u)m(u);return[f,d]},e}();var Se=oe((function(e,n){return e-n}));var Ce=function(e,n){var t=n.value-e.value;return 0===t?e.index-n.index:t};function ze(e,t,r,i){for(void 0===r&&(r=0),void 0===i&&(i=e.length-1);i>r;){if(i-r>600){var o=i-r+1,a=t-r+1,u=Math.log(o),s=.5*Math.exp(2*u/3),l=.5*Math.sqrt(u*s*(o-s)/o)*Math.sign(a-o/2);ze(e,t,Math.max(r,Math.floor(t-a*s/o+l)),Math.min(i,Math.floor(t+(o-a)*s/o+l)))}var d=e[t],p=r,c=i;for(n.util.swap(e,r,t),Ce(e[i],d)>0&&n.util.swap(e,r,i);p<c;){for(n.util.swap(e,p,c),p++,c--;Ce(e[p],d)<0;)p+=1;for(;Ce(e[c],d)>0;)c-=1}0===Ce(e[r],d)?n.util.swap(e,r,c):(c+=1,n.util.swap(e,c,i)),c<=t&&(r=c+1),t<=c&&(i=c-1)}}var _e=ae,Ge=se,Ae=function(e,t,r,i){var o=n.util.getArrayFromDType(r,n.util.sizeFromShape(t));if(i&&"string"!==r){var a=0;e.forEach((function(e){var t=n.util.sizeFromShape(e.shape);o.set(e.vals,a),a+=t}))}else{var u=0;e.forEach((function(e){for(var i="string"===r?n.backend_util.fromUint8ToStringArray(e.vals):e.vals,a=0,s=0;s<e.shape[0];++s)for(var l=s*t[1]+u,d=0;d<e.shape[1];++d)o[l+d]=i[a++];u+=e.shape[1]}))}return o},Te=le,Re=de,Pe=pe,Ne=ce,Be=function(e,t,r,i,o,a,u,s,d){for(var p=n.buffer([i,a],r),c=0;c<i;c++){for(var h=[],f=0,m=0;m<o;m++){var v=e[c*o+m];f+=v*u[m],h.push(v)}if(f<0||f>=d/a)throw new Error("Invalid indices: "+h+" does not index into "+s);for(var g=0;g<a;g++)p.values[c*a+g]=t.get.apply(t,l(t.indexToLoc(f*a+g)))}return p},Le=function(e,t,r){for(var i=n.buffer(r,e.dtype),o=0;o<i.size;++o){var a=i.indexToLoc(o).slice(),u=a[0],s=a[2],l=t.locToIndex([u,s]);a[2]=t.values[l];var d=e.locToIndex(a);0<=d&&d<e.values.length&&(i.values[o]=e.values[d])}return i},We=fe,Ee=he,Oe=ve,Fe=me,Ue=ge,De=function(e,t,r,i){for(var o=n.util.getTypedArrayFromDType(i,n.util.sizeFromShape(r)),a=0;a<o.length;++a){for(var u=a*t,s=e[u],l=0;l<t;++l){var d=e[u+l];(Number.isNaN(d)||d>s)&&(s=d)}o[a]=s}return o},Me=be,Ve=ke,Xe=Ie,He=function(e,t,r){var i=n.util.createScalarValue(-1,r);return Ie([],t,i,e,r)},Ye=xe,qe=function(e,t,r,i){for(var o=s(n.backend_util.computeOutAndReduceShapes(e,i),2),a=o[0],u=o[1],l=n.upcastType(t,"int32"),d=n.util.makeZerosTypedArray(n.util.sizeFromShape(a),l),p=n.util.sizeFromShape(u),c=0;c<d.length;++c){for(var h=c*p,f=1,m=0;m<p;++m)f*=r[h+m];d[c]=f}return{outVals:d,outShape:a,outDtype:l}},je=function(e,t,r,i){if(e===t||e<t&&r<0||t<e&&r>1)return n.util.makeZerosTypedArray(0,i);var o=Math.abs(Math.ceil((t-e)/r)),a=n.util.makeZerosTypedArray(o,i);t<e&&1===r&&(r=-1),a[0]=e;for(var u=1;u<a.length;u++)a[u]=a[u-1]+r;return a},Ke=we,Qe=function(e,t,r,i,o,a,u,s,l,d){var p=[i/o,o],c=e.values,h=t.values;if(0===i)return n.buffer(r,t.dtype);var f=n.buffer(p,t.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(var m=0;m<a;m++){for(var v=[],g=0,b=0;b<u;b++){var k=c[m*u+b];v.push(k),g+=k*s[b]}if(g<0||g>=i/o)throw new Error("Invalid indices: "+v+" does not index into "+r);for(var I=0;I<o;I++)d?f.values[g*o+I]+=h[m*o+I]:f.values[g*o+I]=0===t.rank?h[0]:h[m*o+I]}return f},Ze=function(e){for(var n=new Float32Array(e.length),t=0;t<e.length;++t)n[t]=Math.abs(e[t]);return n},Je=function(e,t,r,i,o){var a=n.slice_util.isSliceContinous(i,t,r),u=n.util.sizeFromShape(r),s=n.util.computeStrides(i);if(a){var d=n.slice_util.computeFlatOffset(t,s);return"string"===o?e.slice(d,d+u):e.subarray(d,d+u)}for(var p="string"===o?n.backend_util.fromUint8ToStringArray(e):e,c=n.buffer(i,o,p),h=n.buffer(r,o),f=0;f<h.size;++f){var m=h.indexToLoc(f),v=m.map((function(e,n){return e+t[n]}));h.set.apply(h,l([c.get.apply(c,l(v))],m))}return"string"===o?n.backend_util.fromStringArrayToUint8(h.values):h.values},$e=function(e,t,r,i){for(var o=n.buffer(e,t.dtype),a=0;a<o.size;a++){for(var u=o.indexToLoc(a),s=new Array(u.length),d=0;d<s.length;d++)s[d]=u[d]*r[d]+i[d];o.set.apply(o,l([t.get.apply(t,l(s))],u))}return o},en=function(e,n,t,r,i,o,a,u){return new ye(t,r,i,o,a,u).compute(e,n)},nn=Se,tn=function(e,t){for(var r=new Array(e.rank),i=0;i<r.length;i++)r[i]=e.shape[i]*t[i];var o=n.buffer(r,e.dtype);for(i=0;i<o.values.length;++i){for(var a=o.indexToLoc(i),u=new Array(e.rank),s=0;s<u.length;s++)u[s]=a[s]%e.shape[s];var l=e.locToIndex(u);o.values[i]=e.values[l]}return o},rn=function(e,t,r,i,o){for(var a=t[t.length-1],u=s([e.length/a,a],2),l=u[0],d=u[1],p=n.util.getTypedArrayFromDType(r,l*i),c=n.util.getTypedArrayFromDType("int32",l*i),h=function(n){var t=n*d,r=e.subarray(t,t+d),a=new Array(r.length);r.forEach((function(e,n){return a[n]={value:e,index:n}})),i<a.length&&(ze(a,i),a=a.slice(0,i)),o&&a.sort(Ce);for(var u=n*i,s=p.subarray(u,u+i),l=c.subarray(u,u+i),h=0;h<i;h++)s[h]=a[h].value,l[h]=a[h].index},f=0;f<l;f++)h(f);var m=t.slice();return m[m.length-1]=i,[n.buffer(m,r,p),n.buffer(m,"int32",c)]},on=function(e,t,r,i,o){for(var a=t.length,u=n.util.sizeFromShape(t),s=n.util.computeStrides(t),l=n.util.computeStrides(o),d=n.util.getTypedArrayFromDType(r,n.util.sizeFromShape(o)),p=0;p<u;++p){for(var c=n.util.indexToLoc(p,a,s),h=new Array(c.length),f=0;f<h.length;f++)h[f]=c[i[f]];d[n.util.locToIndex(h,a,l)]=e[p]}return d},an=re({opType:c.ABS,cpuKernelImpl:Ze}),un={kernelName:n.Abs,backendName:"webgpu",kernelFunc:an},sn=ie({opSnippet:d.ADD,cpuKernelImpl:_e,supportsComplex:!0}),ln={kernelName:n.Add,backendName:"webgpu",kernelFunc:sn},dn=function(){function e(e){this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((function(e,n){return"T"+n})),this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}return e.prototype.getUserCode=function(){var e=[];this.variableNames.forEach((function(n){e.push("let v"+n+" = get"+n+"ByOutputCoords(coords);")}));var n=this.variableNames.map((function(e){return"v"+e})).join(" + ");return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        for (var i = 0; i < "+this.workPerThread+"; i = i + 1) {\n          let flatIndex = index * "+this.workPerThread+" + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            "+e.join("\n        ")+"\n            setOutputAtIndex(flatIndex, "+n+");\n          }\n        }\n      }\n    "},e}();var pn={kernelName:n.AddN,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=t;if(1===i.length)return J({inputs:{x:i[0]},backend:r});var o=i.map((function(e){return e.dtype})).reduce((function(e,t){return n.upcastType(e,t)})),a=i.map((function(e){return e.shape})),u=new dn(a);return r.runWebGPUProgram(u,i,o)}},cn=function(){function e(e,t,r){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;var i=[t];n.backend_util.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,e.length),this.op="min"===r?"<":">";var o=s(n.backend_util.computeOutAndReduceShapes(e,i),1)[0];this.outputShape=0===o.length?[1]:o,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,[1,1,1]),this.inputShape=e,this.shaderKey="argMinMax"+this.op}return e.prototype.getUserCode=function(){var e=this;return"\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      "+("\n      var<workgroup> xBestIndices : array<i32, "+this.workGroupSize[0]+">;\n      var<workgroup> xBestValues : array<f32, "+this.workGroupSize[0]+">;\n    ")+"\n\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        let outputIndex = index / i32(workGroupSizeX);\n        let reduceLength = "+(1===e.inputShape.length?"uniforms.xShape":"uniforms.xShape."+I(e.inputShape.length-1))+";\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + i32(workGroupSizeX)) {\n          let candidate = getX("+function(){var n="";if(1===e.outputShape.length)1!==e.inputShape.length&&(n+="outputCoords,");else for(var t=0;t<e.outputShape.length;t++)n+="outputCoords."+I(t)+",";return n}()+" k);\n          if (!isnan(candidate) && candidate "+this.op+" bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), workGroupSizeX);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate "+this.op+" bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    "},e}(),hn=function(){function e(e,n){this.variableNames=["A"],this.workGroupSize=[16,16,1];for(var t=new Array(e.length),r=0;r<t.length;r++)t[r]=e[n[r]];this.outputShape=t,this.dispatchLayout={x:[0],y:[1]},this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,1,1]),this.shaderKey="transposeShared"}return e.prototype.getUserCode=function(){return"\n      let TILE_DIM = "+this.workGroupSize[0]+";\n      var<workgroup> tile : array<array<f32, "+(this.workGroupSize[0]+1)+">, "+this.workGroupSize[0]+">;\n      \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn main(@builtin(local_invocation_id) localId : vec3<u32>,\n              @builtin(workgroup_id) workgroupId : vec3<u32>) {\n        var x = i32(workgroupId.x) * TILE_DIM + i32(localId.x);\n        var y = i32(workgroupId.y) * TILE_DIM + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = A[y * width + x];\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * TILE_DIM + i32(localId.x);\n        y = i32(workgroupId.x) * TILE_DIM + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    "},e}(),fn=function(){function e(e,n){this.variableNames=["A"],this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0;for(var t=new Array(e.length),r=0;r<t.length;r++)t[r]=e[n[r]];this.outputShape=t,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.newDim=n,this.shaderKey="transpose_"+n}return e.prototype.getUserCode=function(){var e=k(this.outputShape.length),n=function(e){var n=e.length;if(n>6)throw Error("Transpose for rank "+n+" is not yet supported");for(var t=new Array(n),r=0;r<e.length;r++)t[e[r]]="resRC."+I(r);return t.join()}(this.newDim);return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n\n        for(var i = 0; i < "+this.workPerThread+"; i = i + 1) {\n          let flatIndex = index * "+this.workPerThread+" + i;\n          if(flatIndex < uniforms.size) {\n            let resRC = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords"+this.outputShape.length+"D(\n              "+e+"("+n+"), uniforms.aShape)]);\n          }\n        }\n      }\n    "},e}();function mn(e){for(var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=i.perm,u=r,s=o.shape.length,l=new Array(s),d=0;d<l.length;d++)l[d]=o.shape[a[d]];if(r.shouldExecuteOnCPU([o])){var p=u.tensorMap.get(o.dataId).values,c=on(p,o.shape,o.dtype,a,l);return r.makeTensorInfo(l,o.dtype,c)}if(2===o.shape.length&&n.util.arraysEqual(a,[1,0])){var h=new hn(o.shape,a);return u.runWebGPUProgram(h,[o],o.dtype)}var f=new fn(o.shape,a);return u.runWebGPUProgram(f,[o],o.dtype)}var vn={kernelName:n.Transpose,backendName:"webgpu",kernelFunc:mn};var gn={kernelName:n.ArgMax,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=i.axis,u=n.util.parseAxisParam(a,o.shape),s=n.backend_util.getAxesPermutation(u,o.shape.length),l=o,d=[];null!=s&&(l=mn({inputs:{x:o},backend:r,attrs:{perm:s}}),d.push(l),u=n.backend_util.getInnerMostAxes(u.length,l.shape.length)),n.backend_util.assertAxesAreInnerMostDims("argMax",[u[0]],l.shape.length);var p=new cn(l.shape,u[0],"max"),c=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],h=r.runWebGPUProgram(p,[l],"int32",c);return d.forEach((function(e){return r.disposeData(e.dataId)})),h}};var bn={kernelName:n.ArgMin,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=i.axis,u=n.util.parseAxisParam(a,o.shape),s=n.backend_util.getAxesPermutation(u,o.shape.length),l=o,d=[];null!=s&&(l=mn({inputs:{x:o},backend:r,attrs:{perm:s}}),d.push(l),u=n.backend_util.getInnerMostAxes(u.length,l.shape.length)),n.backend_util.assertAxesAreInnerMostDims("argMin",[u[0]],l.shape.length);var p=new cn(l.shape,u[0],"min"),c=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],h=r.runWebGPUProgram(p,[l],"int32",c);return d.forEach((function(e){return r.disposeData(e.dataId)})),h}},kn=function(){function e(e,n){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="pool2D_"+n,this.poolType=n}return e.prototype.getUserCode=function(){var e="resultValue = max(value, resultValue);";"avg"===this.poolType&&(e="resultValue = resultValue + value; count = count + 1.0;");var n="resultValue";return"avg"===this.poolType&&(n="resultValue / count"),"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          var resultValue = "+("avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)")+";\n          var count = 0.0;\n\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, coords[3]);\n              "+e+"\n            }\n          }\n\n          setOutputAtIndex(index, "+n+");\n        }\n      }\n    "},e}(),In=function(){function e(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}return e.prototype.getUserCode=function(){return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.stride;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    "},e}();var xn={kernelName:n.AvgPool,backendName:"webgpu",kernelFunc:function(e){var t,r=e.inputs,i=e.backend,o=e.attrs,a=r.x,u=o.filterSize,s=o.strides,l=o.pad,d=o.dimRoundingMode,p=n.backend_util.computePool2DInfo(a.shape,u,s,1,l,d);if(1===p.filterWidth&&1===p.filterHeight&&n.util.arraysEqual(p.inShape,p.outShape))return J({inputs:{x:a},backend:i});var c=[{type:"int32",data:[p.strideHeight,p.strideWidth]}];return 1===p.filterHeight&&1===p.filterWidth?t=new In(p):(t=new kn(p,"avg"),c.push({type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]})),i.runWebGPUProgram(t,[a],a.dtype,c)}};var wn={kernelName:n.BatchMatMul,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs;return H({a:n.a,b:n.b,transposeA:r.transposeA,transposeB:r.transposeB,backend:t})}},yn=function(){function e(e,n){this.variableNames=["source"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.rank=n.length,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms="start : "+k(e.length)+", ",this.shaderKey="slice"}return e.prototype.getUserCode=function(){var e=k(this.rank),n=function(e){if(1===e)return"sourceLoc";if(e<=6)return Sn.slice(0,e).map((function(e){return"sourceLoc."+e})).join(",");throw Error("Slicing for rank "+e+" is not yet supported")}(this.rank);return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          var sourceLoc : "+e+";\n          let coords = getCoordsFromIndex(index);\n          "+(1===this.start.length?this.outputShape.map((function(e,n){return"sourceLoc = uniforms.start + coords;"})):this.outputShape.map((function(e,n){return"sourceLoc."+Sn[n]+" = uniforms.start["+n+"] + coords."+Sn[n]+";"}))).join("\n")+"\n          setOutputAtIndex(index, getSource("+n+"));\n        }\n      }\n    "},e}(),Sn=["x","y","z","w","u","v"];function Cn(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=i.begin,u=i.size,l=s(n.slice_util.parseSliceParams(o,a,u),2),d=l[0],p=l[1];if(n.slice_util.assertParamsValid(o,d,p),r.shouldExecuteOnCPU([o])||"string"===o.dtype){var c=r.tensorMap.get(o.dataId),h=Je(c.values,d,p,o.shape,o.dtype);return r.makeTensorInfo(p,o.dtype,h)}if(0===n.util.sizeFromShape(p))return r.makeTensorInfo(p,o.dtype,[]);var f=new yn(d,p),m=[{type:"int32",data:d}];return r.runWebGPUProgram(f,[o],o.dtype,m)}var zn={kernelName:n.Slice,backendName:"webgpu",kernelFunc:Cn},_n={kernelName:n.BatchToSpaceND,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=i.blockShape,u=i.crops;n.util.assert(o.shape.length<=4,(function(){return"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"}));var s=a.reduce((function(e,n){return e*n})),l=n.backend_util.getReshaped(o.shape,a,s),d=n.backend_util.getPermuted(l.length,a.length),p=n.backend_util.getReshapedPermuted(o.shape,a,s),c=n.backend_util.getSliceBeginCoords(u,a.length),h=n.backend_util.getSliceSize(p,u,a.length),f=[],m=V({inputs:{x:o},backend:r,attrs:{shape:l}}),v=mn({inputs:{x:m},backend:r,attrs:{perm:d}}),g=V({inputs:{x:v},backend:r,attrs:{shape:p}}),b=Cn({inputs:{x:g},backend:r,attrs:{begin:c,size:h}});return f.push(m),f.push(v),f.push(g),f.forEach((function(e){return r.disposeData(e.dataId)})),b}},Gn=ie({opSnippet:d.NOT_EQUAL,dtype:"bool",cpuKernelImpl:Ye}),An={kernelName:n.NotEqual,backendName:"webgpu",kernelFunc:Gn};function Tn(e){var n=e.inputs,t=e.backend,r=n.input;return J({inputs:{x:t.tensorMap.get(r.dataId).complexTensorInfos.real},backend:t})}var Rn={kernelName:n.Real,backendName:"webgpu",kernelFunc:Tn};var Pn={kernelName:n.Cast,backendName:"webgpu",kernelFunc:function e(t){var i=t.inputs,o=t.backend,a=t.attrs,u=i.x,s=a.dtype;if("complex64"===s){if("complex64"===u.dtype)return J({inputs:{x:u},backend:o});var l=r.zeros(u.shape),d=e({inputs:{x:u},backend:o,attrs:{dtype:"float32"}}),p=ee({inputs:{real:d,imag:l},backend:o});return l.dispose(),o.disposeData(d.dataId),p}if("complex64"===u.dtype){var h=Tn({inputs:{input:u},backend:o}),p=e({inputs:{x:h},backend:o,attrs:{dtype:s}});return o.disposeData(h.dataId),p}if(!n.util.hasEncodingLoss(u.dtype,s))return{dataId:(p=J({inputs:{x:u},backend:o})).dataId,shape:p.shape,dtype:s};if("int32"===s)return function(e,n){var t=new te(e.shape,c.TO_INT),r=n.runWebGPUProgram(t,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(u,o);if("bool"===s){var f=o.makeTensorInfo([],"bool",n.util.getTypedArrayFromDType("bool",1));p=Gn({inputs:{a:u,b:f},backend:o});return o.disposeData(f.dataId),p}throw new Error("Error in Cast: failed to cast "+u.dtype+" to "+s)}},Nn=re({opType:c.CEIL,cpuKernelImpl:Ge}),Bn={kernelName:n.Ceil,backendName:"webgpu",kernelFunc:Nn},Ln=function(){function e(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workGroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}return e.prototype.getUserCode=function(){return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue : vec4<f32>;\n          for (var i = 0; i < 4; i = i + 1) {\n            if (isnan(value[i])) {\n              clampedValue[i] = value[i];\n            } else {\n              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);\n            }\n          }\n\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    "},e}(),Wn=function(){function e(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="clip"}return e.prototype.getUserCode=function(){return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    "},e}();var En={kernelName:n.ClipByValue,backendName:"webgpu",kernelFunc:function(e){var t,r=e.inputs,i=e.backend,o=e.attrs,a=r.x,u=[{type:"float32",data:[o.clipValueMin]},{type:"float32",data:[o.clipValueMax]}];return t=n.util.sizeFromShape(a.shape)%4==0?new Ln(a.shape):new Wn(a.shape),i.runWebGPUProgram(t,[a],a.dtype,u)}},On=function(){function e(e){this.uniforms="",this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=n.backend_util.computeOutShape(e,1),this.variableNames=e.map((function(e,n){return"T"+n})),this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(var t=0;t<this.offsetLength;t++)this.uniforms+="offset"+t+" : i32,";this.shaderKey="concat"}return e.prototype.getUserCode=function(){var e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(var n=1;n<this.offsetLength;n++)e.push("else if (yC < uniforms.offset"+[n]+"){ setOutputAtCoords(coords.x, coords.y, getT"+n+"(yR, yC - uniforms.offset"+(n-1)+")); }");var t=this.offsetLength,r=this.offsetLength-1;e.push("else { setOutputAtCoords(coords.x, coords.y, getT"+t+"(yR, yC - uniforms.offset"+r+")); }")}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        for(var i = 0; i < "+this.workPerThread+"; i = i + 1) {\n          let flatIndex = index * "+this.workPerThread+" + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            "+e.join("\n        ")+"\n          }\n        }\n      }\n    "},e}();function Fn(e){var n=e.inputs,t=e.backend,r=n.input;return J({inputs:{x:t.tensorMap.get(r.dataId).complexTensorInfos.imag},backend:t})}var Un={kernelName:n.Imag,backendName:"webgpu",kernelFunc:Fn};function Dn(e,t,r){var i=e[0].dtype;if("complex64"===i){var o=e.map((function(e){return Tn({inputs:{input:e},backend:r})})),a=e.map((function(e){return Fn({inputs:{input:e},backend:r})})),u=Dn(o,t,r),s=Dn(a,t,r),l=ee({inputs:{real:u,imag:s},backend:r});return o.forEach((function(e){return r.disposeData(e.dataId)})),a.forEach((function(e){return r.disposeData(e.dataId)})),r.disposeData(u.dataId),r.disposeData(s.dataId),l}var d=r.shouldExecuteOnCPU(e);if("string"===i&&(d=!0),d){var p=e.map((function(e){var i=n.util.sizeFromShape(e.shape.slice(t));return V({inputs:{x:e},backend:r,attrs:{shape:[-1,i]}})})),c=p.map((function(e){return{vals:r.readSync(e.dataId),shape:e.shape}})),h=n.backend_util.computeOutShape(p.map((function(e){return e.shape})),1),f=1===p[0].shape[0],m=Ae(c,h,i,f),v=n.backend_util.computeOutShape(e.map((function(e){return e.shape})),t),g=r.makeTensorInfo(v,i,m);return p.forEach((function(e){return r.disposeData(e.dataId)})),g}var b=function(e,t,r){var i=n.backend_util.computeOutShape(e.map((function(e){return e.shape})),t);return{tensors2D:e.map((function(e){return V({inputs:{x:e},backend:r,attrs:{shape:[n.util.sizeFromShape(e.shape.slice(0,t)),n.util.sizeFromShape(e.shape.slice(t))]}})})),outShape:i}}(e,t,r),k=b.tensors2D,I=b.outShape,x=k.map((function(e){return e.shape})),w=new On(x),y=[],S=new Array(x.length-1);if(S.length>0){S[0]=x[0][1],y.push({type:"int32",data:[S[0]]});for(var C=1;C<S.length;C++)S[C]=S[C-1]+x[C][1],y.push({type:"int32",data:[S[C]]})}var z=r.runWebGPUProgram(w,k,k[0].dtype,y);k.forEach((function(e){return r.disposeData(e.dataId)}));var _=V({inputs:{x:z},backend:r,attrs:{shape:I}});return r.disposeData(z.dataId),_}function Mn(e){var t=e.inputs,r=e.backend,i=e.attrs.axis,o=n.util.parseAxisParam(i,t[0].shape)[0],a=n.backend_util.computeOutShape(t.map((function(e){return e.shape})),o);if(0===n.util.sizeFromShape(a))return r.makeTensorInfo(a,t[0].dtype,[]);var u=t.filter((function(e){return n.util.sizeFromShape(e.shape)>0}));if(1===u.length)return J({inputs:{x:u[0]},backend:r});var s=u.map((function(e){return e.shape}));return n.backend_util.assertParamsConsistent(s,o),Dn(u,o,r)}var Vn={kernelName:n.Concat,backendName:"webgpu",kernelFunc:Mn},Xn=function(){function e(e,t,r,i){var o;void 0===t&&(t=!1),void 0===r&&(r=null),void 0===i&&(i=!1),this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>,\n      dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[8,8,1],this.isVec4=!0,this.outputShape=e.outShape,n.util.assert("channelsLast"===e.dataFormat,(function(){return"TODO: NCHW is unimplemented"})),this.dispatchLayout={x:[3],y:[1,2],z:[0]},1===this.outputShape[1]?this.elementsPerThread=[4,1,1]:this.elementsPerThread=[4,4,1],this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivationWeights=i,this.innerElementSize=this.convInfo.inChannels%4==0?4:3,3===this.innerElementSize?this.variableTypes=["f32","vec4<f32>"]:this.variableTypes=["vec4<f32>","vec4<f32>"],this.addBias&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),this.hasPreluActivationWeights&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>")),this.tileAOuter=1===this.outputShape[1]?1:this.workGroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workGroupSize[0]*this.elementsPerThread[0],this.tileInner=this.workGroupSize[0]*this.innerElementSize,o=s(this.getShapeFit(),2),this.fitA=o[0],this.fitB=o[1],this.shaderKey="conv2DMMVec4_"+this.activation+"_"+this.fitA+"_"+this.fitB+"_"+this.elementsPerThread+"_"+this.innerElementSize}return e.prototype.getShapeFit=function(){var e=[this.tileAOuter,this.tileInner],n=[this.tileInner,this.tileBOuter],t=this.outputShape[1]*this.outputShape[2],r=this.outputShape[3],i=this.convInfo.filterHeight*this.convInfo.filterWidth*this.convInfo.inChannels;return[_(e,[t,i]),_(n,[i,r])]},e.prototype.getUserCode=function(){var e=E(this.elementsPerThread,this.tileAOuter,this.tileBOuter,this.tileInner,this.innerElementSize),n="let outRow = r / uniforms.outShape[2];\n        let outCol = r % uniforms.outShape[2];\n        let WRow = c / (uniforms.filterDims[1] * uniforms.xShape[3]);\n        let WCol = c / uniforms.xShape[3] % uniforms.filterDims[1];\n        let inChCoord = c % uniforms.xShape[3];\n        let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n        let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n\n        var resData = vec"+this.innerElementSize+"<f32>(0.0);\n        // The bounds checking is always needed since we use it to pad zero for\n        // the 'same' padding type.\n        if (xRow >= 0 && xRow < uniforms.xShape[1] && xCol >= 0 && xCol < uniforms.xShape[2]) {\n          var coord = vec4<i32>(\n            batch,\n            xRow,\n            xCol,\n            inChCoord);\n          let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n          "+(3===this.innerElementSize?"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);":"resData = x[xIndex / 4];")+"\n        }\n        return resData;",t=this.fitA?""+n:"if (r < uniforms.dimAOuter && c < uniforms.dimInner) {\n          "+n+"\n         }\n         return vec"+this.innerElementSize+"<f32>(0.0);\n        ",r=this.fitB?"return W[row * uniforms.dimBOuter / 4 + col];":"if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {\n           return W[row * uniforms.dimBOuter / 4 + col];\n         }\n         return vec4<f32>(0.0);\n        ",i="",o="";if(this.activation){var a=g(this.activation,this.isVec4);i=this.hasPreluActivationWeights?"fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {\n          let b = getPreluActivationWeightsByOutputCoords(outCoord);\n          "+a+"\n        }":"\n        fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {\n          "+a+"\n        }",o="value = activation(value, outCoord);"}var u=this.addBias?"value = value + getBiasByOutputCoords(outCoord);":"";return"\n        "+i+"\n        fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> vec"+this.innerElementSize+"<f32> {\n          let r = row;\n          let c = col * "+this.innerElementSize+";\n          var batch = i32(globalId.z);\n          "+t+"\n        }\n\n        fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> vec4<f32> {\n          "+r+"\n        }\n\n        fn mm_write(row : i32, col : i32, valueInput : vec4<f32>, globalId : vec3<u32>) {\n          var batch = i32(globalId.z);\n          var value = valueInput;\n          if (row < uniforms.dimAOuter && col * 4 < uniforms.dimBOuter)\n          {\n            let outCoord = vec4<i32>(\n              batch,\n              row / uniforms.outShape[2],\n              row % uniforms.outShape[2],\n              col * 4);\n            "+u+"\n            "+o+"\n            setOutputAtCoords(outCoord[0], outCoord[1], outCoord[2], outCoord[3],\n              value);\n          }\n        }\n        "+e+"\n      "},e}(),Hn=function(){function e(e,n,t,r){var i;void 0===n&&(n=!1),void 0===t&&(t=null),void 0===r&&(r=!1),this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[1],y:[2,3],z:[0]},this.workGroupSize=A(this.dispatchLayout,this.outputShape),this.elementsPerThread=R(this.dispatchLayout,this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=t,this.hasPreluActivationWeights=r,i=s(this.getShapeFit(),2),this.fitA=i[0],this.fitB=i[1],this.shaderKey="conv2DMM_"+this.elementsPerThread+"_"+this.activation+"_"+this.fitA+"_"+this.fitB+"_"+this.isChannelsLast}return e.prototype.getShapeFit=function(){var e=this.workGroupSize[1]*this.elementsPerThread[1],t=this.workGroupSize[0]*this.elementsPerThread[0],r=e>t?e:t;n.util.assert(r%this.workGroupSize[0]==0&&r%this.workGroupSize[1]==0,(function(){return"tileInner must be multiple of workgroupsize.x and workgroupsize.y"}));var i=[e,r],o=[r,t],a=this.convInfo.outHeight*this.convInfo.outWidth,u=this.convInfo.outChannels,s=this.convInfo.filterHeight*this.convInfo.filterWidth*this.convInfo.inChannels;return[_(i,[a,s]),_(o,[s,u])]},e.prototype.getUserCode=function(){var e=this.isChannelsLast?"\n    let coord = vec4<i32>(batch, xRow, xCol, col % inChannels);\n    ":"\n    let coord = vec4<i32>(batch, col % inChannels, xRow, xCol);\n    ",n=this.isChannelsLast?"\n    let outCoord = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let outCoord = vec4<i32>(\n      batch,\n      col,\n      row / outWidth,\n      row % outWidth);\n    ",t=F(this.elementsPerThread,this.workGroupSize),r="\n    let inChannels = uniforms.wShape[2];\n    let outWidth = "+(this.isChannelsLast?"uniforms.outShape[2]":"uniforms.outShape[3]")+";\n    let outRow = row / outWidth;\n    let outCol = row % outWidth;\n\n    let WRow = col / (uniforms.filterDims[1] * inChannels);\n    let WCol = col / inChannels % uniforms.filterDims[1];\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    "+e+"\n    // The bounds checking is always needed since we use it to pad zero for the\n    // 'same' padding type.\n    if(coordsInBounds4D(coord, uniforms.xShape)) {\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)];\n    }\n    return 0.0;",i=this.fitA?""+r:"if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n      "+r+"\n    }\n    return 0.0;\n    ",o=this.fitB?"return W[row * uniforms.dimBOuter + col];":"if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {\n           return W[row * uniforms.dimBOuter + col];\n\t }\n\t return 0.0;\n\t ",a="",u="";if(this.activation){var s=g(this.activation,!1);a=this.hasPreluActivationWeights?"fn activation(a: f32, outCoord : vec4<i32>) -> f32 {\n                  let b = getPreluActivationWeightsByOutputCoords(outCoord);\n                  "+s+"\n                }":"\n                  fn activation(a : f32, outCoord : vec4<i32>) -> f32 {\n                    "+s+"\n                  }\n                ",u="value = activation(value, outCoord);"}var l=this.addBias?"value = value + getBiasByOutputCoords(outCoord);":"";return"\n    "+a+"\n    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {\n      var batch = i32(globalId.z);\n      "+i+"\n    }\n\n    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {\n      "+o+"\n    }\n\n    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {\n      var batch = i32(globalId.z);\n      var value = valueInput;\n      let outWidth = "+(this.isChannelsLast?"uniforms.outShape[2]":"uniforms.outShape[3]")+";\n      "+n+"\n      "+l+"\n      "+u+"\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)] = value;\n    }\n    "+t+"\n  "},e}();function Yn(e){var n,t=e.x,r=e.filter,i=e.convInfo,o=e.backend,a=e.bias,u=void 0===a?null:a,s=e.preluActivationWeights,d=void 0===s?null:s,p=e.leakyreluAlpha,c=void 0===p?0:p,h=e.activation,f=void 0===h?null:h,m=null!=u,v=null!=d,g="channelsLast"===i.dataFormat;if(g&&i.filterHeight===i.inHeight&&i.filterWidth===i.inWidth&&"VALID"===i.padInfo.type||1===i.filterHeight&&1===i.filterWidth&&1===i.dilationHeight&&1===i.dilationWidth&&1===i.strideHeight&&1===i.strideWidth&&("SAME"===i.padInfo.type||"VALID"===i.padInfo.type))return function(e){var n,t,r=e.x,i=e.filter,o=e.convInfo,a=e.backend,u=e.bias,s=void 0===u?null:u,l=e.preluActivationWeights,d=void 0===l?null:l,p=e.leakyreluAlpha,c=void 0===p?0:p,h=e.activation,f=void 0===h?null:h,m="channelsLast"===o.dataFormat,v=!m;if(m&&o.filterHeight===o.inHeight&&o.filterWidth===o.inWidth&&"VALID"===o.padInfo.type){var g=o.inHeight*o.inWidth*o.inChannels;n=V({inputs:{x:r},backend:a,attrs:{shape:[1,o.batchSize,g]}}),t=V({inputs:{x:i},backend:a,attrs:{shape:[1,g,o.outChannels]}})}else n=V({inputs:{x:r},backend:a,attrs:{shape:m?[o.batchSize,o.inHeight*o.inWidth,o.inChannels]:[o.batchSize,o.inChannels,o.inHeight*o.inWidth]}}),t=V({inputs:{x:i},backend:a,attrs:{shape:[1,o.inChannels,o.outChannels]}});var b=H({a:m?n:t,b:m?t:n,transposeA:v,transposeB:!1,backend:a,bias:s,activation:f,preluActivationWeights:d,leakyreluAlpha:c}),k=V({inputs:{x:b},backend:a,attrs:{shape:o.outShape}});return a.disposeData(n.dataId),a.disposeData(t.dataId),a.disposeData(b.dataId),k}({x:t,filter:r,convInfo:i,backend:o,bias:u,activation:f,preluActivationWeights:d,leakyreluAlpha:c});var b=(i.inChannels%4==0||i.inChannels%3==0)&&i.outChannels%4==0&&g,k=[i.padInfo.top,i.padInfo.left],I=[{type:"int32",data:[i.filterHeight,i.filterWidth]},{type:"int32",data:l(k)},{type:"int32",data:[i.strideHeight,i.strideWidth]},{type:"int32",data:[i.dilationHeight,i.dilationWidth]}];n=b?new Xn(i,m,f,v):new Hn(i,m,f,v);var x=i.outHeight*i.outWidth,w=i.outChannels,y=i.filterHeight*i.filterWidth*i.inChannels;I.push({type:"int32",data:[x]},{type:"int32",data:[w]},{type:"int32",data:[y]});var S=[t,r];return m&&S.push(u),v&&S.push(d),"leakyrelu"===f&&(I.push({type:"float32",data:[c]}),n.uniforms+=" alpha : f32,"),o.runWebGPUProgram(n,S,t.dtype,I)}var qn={kernelName:n.Conv2D,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.attrs,i=e.backend,o=t.x,a=t.filter,u=r.strides,s=r.pad,l=r.dataFormat,d=r.dilations,p=r.dimRoundingMode,c=n.backend_util.convertConv2DDataFormat(l);return Yn({x:o,filter:a,convInfo:n.backend_util.computeConv2DInfo(o.shape,a.shape,u,d,s,p,!1,c),backend:i})}},jn=function(){function e(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,n.util.assert("channelsLast"===e.dataFormat,(function(){return"TODO: NCHW is unimplemented"})),this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=A(this.dispatchLayout,this.outputShape),this.elementsPerThread=R(this.dispatchLayout,this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.shaderKey="conv2DDerInputMM_"+this.elementsPerThread}return e.prototype.getUserCode=function(){return"\n    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {\n      var batch = i32(globalId.z);\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n      \n    let outRow = row / uniforms.outShape[2];\n    let outCol = row % uniforms.outShape[2];\n\n    let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n    let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);\n    let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);\n    if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n      return 0.0;\n    }\n    if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n      return 0.0;\n    }\n    let coord = vec4<i32>(\n        batch,\n        i32(xR),\n        i32(xC),\n        col % uniforms.outBackprop[3]);\n    return x[getIndexFromCoords4D(coord, uniforms.xShape)];\n    }\n    return 0.0;\n    }\n\n    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {\n      let coordX = uniforms.filterDims.x - 1 -\n          row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let coordY = uniforms.filterDims.y - 1 -\n          (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n          coordX >= 0 && coordY >= 0) {\n        let coord = vec4<i32>(coordX, coordY, col,\n            row % uniforms.outBackprop[3]);\n        return W[getIndexFromCoords4D(coord, uniforms.wShape)];\n      }\n      return 0.0;\n    }\n\n    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {\n      var batch = i32(globalId.z);\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)] = value;\n    }\n\n    "+F(this.elementsPerThread,this.workGroupSize)+"\n  "},e}(),Kn=function(){function e(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey="conv2DDerInput_"+this.isChannelsLast}return e.prototype.getUserCode=function(){var e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3;return"\n    \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords["+(this.isChannelsLast?3:1)+"];\n\n        let dyCorner = vec2<i32>(coords["+e+"]), coords["+n+"]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = dyR;\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = dyC;\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              if ("+this.isChannelsLast+") {\n                let xValue = getDy(batch, idyR, idyC, d2);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              } else {\n                let xValue = getDy(batch, d2, idyR, idyC);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  "},e}();var Qn,Zn={kernelName:n.Conv2DBackpropInput,backendName:"webgpu",kernelFunc:function(e){var t,r=e.inputs,i=e.backend,o=e.attrs,a=r.dy,u=r.filter,s=o.inputShape,l=o.strides,d=o.pad,p=o.dataFormat,c=o.dimRoundingMode,h=n.backend_util.convertConv2DDataFormat(p),f=n.backend_util.computeConv2DInfo(s,u.shape,l,1,d,c,!1,h),m=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];if(n.env().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE"))t=new Kn(f);else{t=new jn(f);var v=f.inShape[1]*f.inShape[2],g=f.inShape[3],b=f.filterHeight*f.filterWidth*f.outChannels;m.push({type:"uint32",data:[v]},{type:"uint32",data:[g]},{type:"uint32",data:[b]})}return i.runWebGPUProgram(t,[a,u],"float32",m)}},Jn=re({opType:c.COS}),$n={kernelName:n.Cos,backendName:"webgpu",kernelFunc:Jn},et=re({opType:c.COSH}),nt={kernelName:n.Cosh,backendName:"webgpu",kernelFunc:et},tt=function(){function e(e,n,t,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workGroupSize=[64,1,1],this.size=!0;var i=s(n,1)[0];this.outputShape=[i,t[0],t[1],e],this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.methodId="bilinear"===r?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey="cropAndResize_"+this.methodId+"_"+this.cropHeightBiggerThan1+"_"+this.cropWidthBiggerThan1}return e.prototype.getUserCode=function(){var e=s(["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],2),n=e[0],t=e[1],r=s(this.cropHeightBiggerThan1?["("+n+" / f32(uniforms.outShape[1] - 1))","(y2-y1) * height_ratio","y1*"+n+" + f32(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+n],3),i=r[0],o=r[1],a=r[2],u=s(this.cropWidthBiggerThan1?["("+t+" / f32(uniforms.outShape[2] - 1))","(x2-x1) * width_ratio","x1*"+t+" + f32(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+t],3);return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32("+i+");\n        let width_ratio = f32("+u[0]+");\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = "+o+";\n        let width_scale = "+u[1]+";\n        let in_y = "+a+";\n        if( in_y < 0.0 || in_y > "+n+" ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = "+u[2]+";\n        if( in_x < 0.0 || in_x > "+t+" ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if("+this.methodId+" == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    "},e}(),rt={kernelName:n.CropAndResize,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,i=n.image,o=n.boxes,a=n.boxInd,u=r.cropSize,s=r.method,l=r.extrapolationValue,d=new tt(i.shape[3],o.shape,u,s),p=[{type:"float32",data:[l]}];return t.runWebGPUProgram(d,[i,o,a],"float32",p)}};!function(e){e.Prod="*",e.Sum="+"}(Qn||(Qn={}));var it=function(){function e(e,n,t,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=n,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.exclusive=t,this.reverse=r,this.op=e,this.shaderKey="cum_"+this.op+"_"+this.exclusive+"_"+this.reverse}return e.prototype.getUserCode=function(){var e=this.outputShape.length,n=this.op===Qn.Prod?"1.0":"0.0",t=this.exclusive?n:"getX("+ot(e,"coords",this.op)+")",r=this.outputShape[this.outputShape.length-1],i="",o="";return this.exclusive?(i=this.reverse?"end != "+(r-1):"end != 0",o=this.reverse?"end + 1":"end - 1"):(i=this.reverse?"end + pow2 < "+r:"end >= pow2",o=this.reverse?"end + pow2":"end - pow2"),"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = "+at(e,"coords",this.op)+";\n         var val = "+t+";\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if ("+i+") {\n           let idx = "+o+";\n           "+at(e,"coords",this.op)+" = idx;\n           val "+this.op+"= getX("+ot(e,"coords",this.op)+");\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    "},e}();function ot(e,n,t){if(1===e)return""+n;if(2===e)return n+".x, "+n+".y";if(3===e)return n+".x, "+n+".y, "+n+".z";if(4===e)return n+".x, "+n+".y, "+n+".z, "+n+".w";throw Error("Cumulative "+t+" for rank "+e+" is not yet supported")}function at(e,n,t){if(1===e)return""+n;if(2===e)return n+".y";if(3===e)return n+".z";if(4===e)return n+".w";throw Error("Cumulative "+t+" for rank "+e+" is not yet supported")}function ut(e,t,r,i,o,a){var u=t.shape.length,s=n.backend_util.getAxesPermutation([i],u),l=t;null!=s&&(l=mn({inputs:{x:t},backend:r,attrs:{perm:s}}));var d=n.backend_util.getInnerMostAxes(1,u)[0];if(d!==u-1)throw new Error("WebGPU cumprod shader expects an inner-most axis="+(t.shape.length-1)+" but got axis="+i);for(var p=l.shape[d],c=J({inputs:{x:l},backend:r}),h=0;h<=Math.ceil(Math.log2(p))-1;h++){var f=new it(e,l.shape,!1,a),m=c,v=[{type:"float32",data:[h]}];c=r.runWebGPUProgram(f,[c],c.dtype,v),r.disposeData(m.dataId)}if(o){f=new it(e,l.shape,o,a),m=c,v=[{type:"float32",data:[0]}];c=r.runWebGPUProgram(f,[c],c.dtype,v),r.disposeData(m.dataId)}if(null!=s){var g=mn({inputs:{x:c},backend:r,attrs:{perm:n.backend_util.getUndoAxesPermutation(s)}});return r.disposeData(c.dataId),r.disposeData(l.dataId),g}return c}var st={kernelName:n.Cumprod,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,i=n.x,o=r.axis,a=r.exclusive,u=r.reverse;return ut(Qn.Prod,i,t,o,a,u)}};var lt={kernelName:n.Cumsum,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,i=n.x,o=r.axis,a=r.exclusive,u=r.reverse;return ut(Qn.Sum,i,t,o,a,u)}},dt=function(){function e(e,n){this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="depthToSpace_"+n,this.dataFormat=n}return e.prototype.getUserCode=function(){return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = "+this.getHeightCoordString()+";\n          let w = "+this.getWidthCoordString()+";\n          let d = "+this.getDepthCoordString()+";\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            "+this.getOutputDepthSize()+";\n          let in_d = d + offset_d;\n\n          let rlt = "+this.getInputSamplingString()+";\n          setOutputAtIndex(index, rlt);\n        }\n      }"},e.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},e.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},e.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},e.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"},e.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},e}();var pt={kernelName:n.DepthToSpace,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,i=n.x,o=r.blockSize,a=r.dataFormat,u=i.shape[0],s=("NHWC"===a?i.shape[1]:i.shape[2])*o,l=("NHWC"===a?i.shape[2]:i.shape[3])*o,d=("NHWC"===a?i.shape[3]:i.shape[1])/(o*o),p=[{type:"int32",data:[o]}],c=new dt("NHWC"===a?[u,s,l,d]:[u,d,s,l],a);return t.runWebGPUProgram(c,[i],i.dtype,p)}},ct=function(){function e(e,t,r,i){void 0===t&&(t=!1),void 0===r&&(r=null),void 0===i&&(i=!1),this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[4,4,4],this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[0,1],y:[2],z:[3]},this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,4,4]),n.util.assert("channelsLast"===e.dataFormat,(function(){return"TODO: NCHW is unimplemented"})),t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=i,this.shaderKey="depthwise3x3_"+r}return e.prototype.getUserCode=function(){var e="",n="";if(this.activation){var t=g(this.activation,this.isVec4);e=this.hasPreluActivation?"fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {\n          let b = getPreluActivationWeightsByOutputCoords(outCoord);\n          "+t+"\n        }":"\n        fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {\n            "+t+"\n          }\n        ",n="dotProd[i] = activation(dotProd[i], coords);"}return"\n      "+e+"\n\n      \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn main(@builtin(global_invocation_id) globalId: vec3<u32>) {\n        let batch = 0;\n        let r = i32(globalId.x);\n        let c = i32(globalId.y) * 4;\n        let d2 = i32(globalId.z) * 4;\n        let xRCCorner = vec2<i32>(r, c) * uniforms.stride - uniforms.pad;\n        let d1 = d2;\n        let q = 0;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n\n        var wVals : array<vec4<f32>, 9>;\n        wVals[0] = getW(0, 0, d1, q);\n        wVals[1] = getW(0, 1, d1, q);\n        wVals[2] = getW(0, 2, d1, q);\n        wVals[3] = getW(1, 0, d1, q);\n        wVals[4] = getW(1, 1, d1, q);\n        wVals[5] = getW(1, 2, d1, q);\n        wVals[6] = getW(2, 0, d1, q);\n        wVals[7] = getW(2, 1, d1, q);\n        wVals[8] = getW(2, 2, d1, q);\n\n        var xVals : array<array<vec4<f32>, 6>, 3>;\n        for (var wR = 0; wR < 3; wR = wR + 1) {\n          let xR = xRCorner + wR * uniforms.dilation[0];\n          for (var wC = 0; wC < 6; wC = wC + 1) {\n            let xC = xCCorner + wC * uniforms.dilation[1];\n            if (xR < 0 || xR >= uniforms.inDims[0] || xC < 0 || xC >= uniforms.inDims[1]) {\n              xVals[wR][wC] = vec4<f32>(0.0);\n            } else {\n              xVals[wR][wC] = getX(batch, xR, xC, d1);\n            }\n          }\n        }\n\n        var dotProd : array<vec4<f32>, 4>;\n        dotProd[0] = vec4<f32>(0.0);\n        dotProd[1] = vec4<f32>(0.0);\n        dotProd[2] = vec4<f32>(0.0);\n        dotProd[3] = vec4<f32>(0.0);\n\n        for (var wR = 0; wR < 3; wR = wR + 1) {\n          for (var wC = 0; wC < 3; wC = wC + 1) {\n            let indexW = wR * 3 + wC;\n            dotProd[0] = dotProd[0] + xVals[wR][0 + wC] * wVals[indexW];\n            dotProd[1] = dotProd[1] + xVals[wR][1 + wC] * wVals[indexW];\n            dotProd[2] = dotProd[2] + xVals[wR][2 + wC] * wVals[indexW];\n            dotProd[3] = dotProd[3] + xVals[wR][3 + wC] * wVals[indexW];\n          }\n        }\n\n        for (var i = 0; i < 4; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d2);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            "+(this.addBias?"dotProd[i] = dotProd[i] + getBiasByOutputCoords(coords);":"")+"\n            "+n+"\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);\n          }\n        }\n      }\n    "},e}(),ht=function(){function e(e,t,r,i){void 0===t&&(t=!1),void 0===r&&(r=null),void 0===i&&(i=!1),this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>,\n      inDims : vec2<i32>, filterHeight : i32, filterWidth : i32,\n      channelMul : i32,",this.workGroupSize=[256,1,1],this.outputShape=e.outShape,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),n.util.assert("channelsLast"===e.dataFormat,(function(){return"TODO: NCHW is unimplemented"})),t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=i,this.shaderKey="depthwise_"+this.activation}return e.prototype.getUserCode=function(){var e="",n="";if(this.activation){var t=g(this.activation,!1);e=this.hasPreluActivation?"fn activation(a : f32, outCoord : vec4<i32>) -> f32 {\n          let b = getPreluActivationWeightsByOutputCoords(outCoord);\n          "+t+"\n        }":"\n          fn activation(a : f32, outCoord : vec4<i32>) -> f32 {\n            "+t+"\n          }\n        ",n="dotProd = activation(dotProd, coords);"}return"\n      "+e+"\n\n      fn writeResult(batch : i32, row : i32, col : i32, chan : i32,\n          value : f32) {\n        let coord = vec4<i32>(batch, row, col, chan);\n        if (coordsInBounds4D(coord, uniforms.outShape)) {\n          setOutputAtCoords(batch, row, col, chan, value);\n        }\n      }\n\n      \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n        let d2 = coords[3];\n        let d1 = d2 / uniforms.channelMul;\n        let q = d2 - d1 * uniforms.channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n        let inputRowEnd = inputRowStart + uniforms.filterHeight *\n            uniforms.dilation[0];\n        let inputColEnd = inputColStart + uniforms.filterWidth *\n            uniforms.dilation[1];\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n\n        // Extract if checking out of for loop for performance.\n        if (inputRowStart >= 0 && inputColStart >= 0 &&\n          inputRowEnd < uniforms.inDims[0] &&\n              inputColEnd < uniforms.inDims[1]) {\n            // Here using a constant value |this.convInfo.filterHeight| instead\n            // of uniform value is in order to loop unrolling.\n            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n              let xR = inputRowStart + wR * uniforms.dilation[0];\n\n              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                let xC = inputColStart + wC * uniforms.dilation[1];\n\n                let xVal = getX(batch, xR, xC, d1);\n                let wVal = getW(wR, wC, d1, q);\n                dotProd = dotProd + xVal * wVal;\n              }\n            }\n          } else {\n            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n              let xR = inputRowStart + wR * uniforms.dilation[0];\n\n              if (xR < 0 || xR >= uniforms.inDims[0]) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                let xC = inputColStart + wC * uniforms.dilation[1];\n\n                if (xC < 0 || xC >= uniforms.inDims[1]) {\n                  continue;\n                }\n\n                let xVal = getX(batch, xR, xC, d1);\n                let wVal = getW(wR, wC, d1, q);\n                dotProd = dotProd + xVal * wVal;\n              }\n            }\n          }\n\n        "+(this.addBias?"dotProd = dotProd + getBiasByOutputCoords(coords);":"")+"\n        "+n+"\n        writeResult(batch, coords[1], coords[2], d2, dotProd);\n      }\n    "},e}();var ft={kernelName:n.DepthwiseConv2dNative,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=t.filter,u=i.strides,s=i.pad,l=i.dilations,d=i.dimRoundingMode,p=l;null==p&&(p=[1,1]);var c,h=n.backend_util.computeConv2DInfo(o.shape,a.shape,u,p,s,d,!0),f=[{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.inHeight,h.inWidth]}];return 1===h.batchSize&&h.inHeight===h.outHeight&&h.inWidth===h.outWidth&&1===h.strideHeight&&1===h.strideWidth&&h.filterHeight===h.filterWidth&&h.inChannels===h.outChannels&&1===h.dilationHeight&&1===h.dilationWidth&&3===h.filterHeight&&h.inChannels%4==0?c=new ct(h):(c=new ht(h),f.push({type:"int32",data:[h.filterHeight]},{type:"int32",data:[h.filterWidth]},{type:"int32",data:[h.outChannels/h.inChannels]})),r.runWebGPUProgram(c,[o,a],o.dtype,f)}},mt=ie({opSnippet:d.MUL,cpuKernelImpl:Xe,supportsComplex:!0}),vt={kernelName:n.Multiply,backendName:"webgpu",kernelFunc:mt},gt=function(){function e(e,t){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];var r=s(n.backend_util.computeOutAndReduceShapes(this.inputShape,[1]),1)[0];this.outputShape=0===r.length?[1]:r,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey="reduce_"+t}return e.prototype.getUserCode=function(){var e="",n="0.0";"min"===this.reduceType||"max"===this.reduceType?(e="\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate "+("min"===this.reduceType?"<":">")+" bestValue)\n           {  bestValue = candidate; }",n="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType&&(e=" bestValue = bestValue * candidate; ",n="1.0");var t="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return"\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       "+("\n         var<workgroup> xBestValues : array<f32, "+this.workGroupSize[0]+">;\n       ")+"\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = "+(1===this.outputShape.length?"outputCoords":"outputCoords[0]")+" * uniforms.reduceSize;\n          return offset;\n       }\n       \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n         let outputIndex = index / i32(workGroupSizeX);\n         let offset = getOffset(outputIndex);\n         var bestValue = "+n+";\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), workGroupSizeX);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + i32(workGroupSizeX)) {\n           let candidate = f32(x[offset + k]);\n           "+e+"\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), workGroupSizeX);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            "+e+"\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          "+t+"\n        }\n       }\n     "},e}();function bt(e,t,r,i,o){var a=e.shape.length,u=[],l=n.util.parseAxisParam(t,e.shape),d=l,p=n.backend_util.getAxesPermutation(d,a),c=e;null!=p&&(c=mn({inputs:{x:e},attrs:{perm:p},backend:o}),d=n.backend_util.getInnerMostAxes(d.length,a),u.push(c)),n.backend_util.assertAxesAreInnerMostDims(i,d,a);var h,f=s(n.backend_util.computeOutAndReduceShapes(c.shape,d),2),m=f[0],v=f[1],g=m;if(r&&(g=n.backend_util.expandShapeToKeepDim(m,l)),"max"!==i&&"prod"!==i||!o.shouldExecuteOnCPU([c])){var b=n.util.sizeFromShape(v),k={windowSize:b,inSize:b,batchSize:n.util.sizeFromShape(c.shape)/b,outSize:1},I="mean"===i?"float32":n.sumOutType(e.dtype),x=[{type:"int32",data:[b]}],w=new gt(k,i),y=o.runWebGPUProgram(w,[c],I,x);u.push(y),h=V({inputs:{x:y},attrs:{shape:g},backend:o})}else{var S=o.tensorMap.get(c.dataId).values;switch(i){case"max":var C=De(S,n.util.sizeFromShape(v),g,e.dtype);h=o.makeTensorInfo(g,e.dtype,C);break;case"prod":var z=qe(c.shape,c.dtype,S,d),_=z.outVals,G=z.outShape,A=z.outDtype;h=o.makeTensorInfo(G,A,_);break;default:throw new Error(i+" CPU implementation is not yet supported.")}}return u.forEach((function(e){return o.disposeData(e.dataId)})),h}function kt(e){var n=e.inputs,t=e.backend,r=e.attrs;return bt(n.x,r.axis,r.keepDims,"sum",t)}var It={kernelName:n.Sum,backendName:"webgpu",kernelFunc:kt};var xt={kernelName:n.Einsum,backendName:"webgpu",kernelFunc:function(e){var t,r,i,o,a=e.inputs,s=e.backend,l=e.attrs.equation,d=a,p=n.backend_util.decodeEinsumEquation(l,d.length),c=p.allDims,h=p.summedDims,f=p.idDims;n.backend_util.checkEinsumDimSizes(c.length,f,d);for(var m=n.backend_util.getEinsumComputePath(h,f),v=m.path,g=m.steps,b=g.length,k=null,I=c.length,x=[],w=0;w<b;++w){try{for(var y=(t=void 0,u(g[w])),S=y.next();!S.done;S=y.next()){var C=S.value,z=n.backend_util.getEinsumPermutation(I,f[C]),_=z.permutationIndices,G=z.expandDims,A=void 0;n.backend_util.isIdentityPermutation(_)?A=d[C]:(A=mn({inputs:{x:d[C]},backend:s,attrs:{perm:_}}),x.push(A));for(var T=A.shape.slice(),R=0;R<G.length;++R)T.splice(G[R],0,1);n.util.arraysEqual(A.shape,T)||(A=V({inputs:{x:A},backend:s,attrs:{shape:T}}),x.push(A)),null===k?k=A:(k=mt({inputs:{a:A,b:k},backend:s}),x.push(k))}}catch(e){t={error:e}}finally{try{S&&!S.done&&(r=y.return)&&r.call(y)}finally{if(t)throw t.error}}w<b-1&&(v[w]>=0&&(k=kt({inputs:{x:k},backend:s,attrs:{axis:v[w]-(c.length-I),keepDims:!1}}),x.push(k)),I--)}try{for(var P=u(x),N=P.next();!N.done;N=P.next()){var B=N.value;B!==k&&s.disposeData(B.dataId)}}catch(e){i={error:e}}finally{try{N&&!N.done&&(o=P.return)&&o.call(P)}finally{if(i)throw i.error}}return k}},wt=re({opType:c.ELU}),yt={kernelName:n.Elu,backendName:"webgpu",kernelFunc:wt},St=ie({opSnippet:d.EQUAL,dtype:"bool",cpuKernelImpl:Te}),Ct={kernelName:n.Equal,backendName:"webgpu",kernelFunc:St},zt=re({opType:c.EXP,cpuKernelImpl:Re,dtype:"float32"}),_t={kernelName:n.Exp,backendName:"webgpu",kernelFunc:zt};function Gt(e){var t=e.inputs,r=e.attrs,i=e.backend,o=r.dim,a=t.input,u=a.shape.length,s=a.shape.slice(),l=o;return o<0&&(n.util.assert(-(u+1)<=o,(function(){return"Axis must be in the interval ["+-(u+1)+", "+u+"]"})),l=u+o+1),s.splice(l,0,1),V({inputs:{x:a},backend:i,attrs:{shape:s}})}var At={kernelName:n.ExpandDims,backendName:"webgpu",kernelFunc:Gt},Tt=re({opType:c.EXPM1,cpuKernelImpl:Pe}),Rt={kernelName:n.Expm1,backendName:"webgpu",kernelFunc:Tt},Pt=function(){function e(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="fill"}return e.prototype.getUserCode=function(){return"\n    \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  "},e}();function Nt(e){var t=e.backend,r=e.attrs,i=r.shape,o=r.value,a=r.dtype;if("string"===(a=a||n.util.inferDtype(o))){var u=n.util.getArrayFromDType(a,n.util.sizeFromShape(i));return u.fill(o),t.makeTensorInfo(i,a,u)}var s=new Pt(i),l=[{type:"float32",data:[o]}];return t.runWebGPUProgram(s,[],a,l)}var Bt,Lt={kernelName:n.Fill,backendName:"webgpu",kernelFunc:Nt},Wt=function(){function e(e){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="flipLeftRight"}return e.prototype.getUserCode=function(){return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    "},e}(),Et={kernelName:n.FlipLeftRight,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=n.image,i=t,o=new Wt(r.shape);return i.runWebGPUProgram(o,[r],r.dtype)}},Ot=re({opType:c.FLOOR,cpuKernelImpl:Ne}),Ft={kernelName:n.Floor,backendName:"webgpu",kernelFunc:Ot},Ut=ie({opSnippet:d.INT_DIV,dtype:"int32"}),Dt={kernelName:n.FloorDiv,backendName:"webgpu",kernelFunc:Ut},Mt=function(){function e(e,n){void 0===n&&(n=!1),this.outputShape=[0],this.variableNames=[],this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.useImport=n,this.shaderKey="fromPixels_"+this.useImport}return e.prototype.getUserCode=function(){var e=this.useImport?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return"\n      @binding(1) @group(0) var src: "+(this.useImport?"texture_external":"texture_2d<f32>")+";\n\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        let flatIndexBase = index * uniforms.numChannels;\n        for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n          let flatIndex = flatIndexBase + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndexBase);\n            let values = "+e+";\n            result[flatIndex] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  "},e}(),Vt={kernelName:n.FromPixels,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.pixels,a=i.numChannels;if(null==o)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var u="undefined"!=typeof HTMLVideoElement&&o instanceof HTMLVideoElement,l="undefined"!=typeof HTMLImageElement&&o instanceof HTMLImageElement,d="undefined"!=typeof HTMLCanvasElement&&o instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&o instanceof OffscreenCanvas,p="undefined"!=typeof ImageBitmap&&o instanceof ImageBitmap,c=s(u?[o.videoWidth,o.videoHeight]:[o.width,o.height],2),h=c[0],f=c[1],m=[f,h,a];if(n.env().getBool("WEBGPU_USE_IMPORT")&&u)return Xt({externalImage:o,backend:r,attrs:i,outShape:m,useImport:!0});(u||l)&&(null==Bt&&(Bt=document.createElement("canvas").getContext("2d")),Bt.canvas.width=h,Bt.canvas.height=f,Bt.drawImage(o,0,0,h,f),o=Bt.canvas);if(p||d||u||l)return Xt({externalImage:o,backend:r,attrs:i,outShape:m,useImport:!1});var v=o.data,g=v;if(null!=a&&4!==a){g=new Uint8Array(o.width*o.height*a);for(var b=v.length,k=0,I=0;I<b;I++)I%4<a&&(g[k++]=v[I])}var x=r.makeTensorInfo(m,"int32");return r.tensorMap.get(x.dataId).values=new Int32Array(g),r.maybeReleaseBuffer(x.dataId),r.uploadToGPU(x.dataId),x}};function Xt(e){var t=e.externalImage,r=e.backend,i=e.attrs,o=e.outShape,a=e.useImport,u=i.numChannels,s=n.util.sizeFromShape(o),d=n.util.computeStrides(o),p=new Mt(o,a),c=[{type:"uint32",data:[s]},{type:"uint32",data:[u]},{type:"uint32",data:l(d)},{type:"uint32",data:l(p.dispatch)}];return r.runFromPixelsProgram(p,o,c,a,t)}var Ht=function(){function e(e,t,r,i,o){this.uniforms="varianceEpsilon : f32,",this.workGroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],n.backend_util.assertAndGetBroadcastShape(e,t),n.backend_util.assertAndGetBroadcastShape(e,r),this.outputShape=e,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),null!=i&&(n.backend_util.assertAndGetBroadcastShape(e,i),this.variableNames.push("offset")),null!=o&&(n.backend_util.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale")),this.offsetShape=i,this.scaleShape=o,this.shaderKey="batchNorm"}return e.prototype.getUserCode=function(){var e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");var n="1.0";return null!=this.scaleShape&&(n="getScaleByOutputIndex(index)"),"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = "+e+";\n          let scaleValue = "+n+";\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  "},e}(),Yt={kernelName:n.FusedBatchNorm,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.attrs,r=e.backend,i=n.x,o=n.scale,a=n.offset,u=n.mean,s=n.variance,l=t.varianceEpsilon,d=r,p=[i,u,s],c=null;null!=a&&(c=a.shape,p.push(a));var h=null;null!=o&&(h=o.shape,p.push(o));var f=new Ht(i.shape,u.shape,s.shape,c,h),m=[{type:"float32",data:[l]}];return d.runWebGPUProgram(f,p,i.dtype,m)}};var qt={kernelName:n.FusedConv2D,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=t.filter,u=t.bias,s=t.preluActivationWeights,l=i.strides,d=i.pad,p=i.dataFormat,c=i.dilations,h=i.dimRoundingMode,f=i.activation,m=i.leakyreluAlpha;if("NHWC"!==p)throw new Error("WebGPU backend FusedConv2D does not support dataFormat:'"+p+"'. Please use 'NHWC'.");var v=n.backend_util.convertConv2DDataFormat(p);return Yn({x:o,filter:a,convInfo:n.backend_util.computeConv2DInfo(o.shape,a.shape,l,c,d,h,!1,v),backend:r,bias:u,preluActivationWeights:s,leakyreluAlpha:m,activation:f})}};var jt={kernelName:n.FusedDepthwiseConv2D,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=t.filter,u=t.bias,s=t.preluActivationWeights,l=i.strides,d=i.pad,p=i.dilations,c=i.dimRoundingMode,h=i.activation,f=i.leakyreluAlpha,m=p;null==m&&(m=[1,1]),n.util.assert(n.backend_util.eitherStridesOrDilationsAreOne(l,m),(function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+l+" and dilations '"+m+"'"}));var v=n.backend_util.computeConv2DInfo(o.shape,a.shape,l,m,d,c,!0),g=[o,a],b=null!=u,k=null!=s;b&&g.push(u),k&&g.push(s);var I,x=[{type:"int32",data:[v.padInfo.top,v.padInfo.left]},{type:"int32",data:[v.strideHeight,v.strideWidth]},{type:"int32",data:[v.dilationHeight,v.dilationWidth]},{type:"int32",data:[v.inHeight,v.inWidth]}];return 1===v.batchSize&&v.inHeight===v.outHeight&&v.inWidth===v.outWidth&&1===v.strideHeight&&1===v.strideWidth&&v.filterHeight===v.filterWidth&&v.inChannels===v.outChannels&&1===v.dilationHeight&&1===v.dilationWidth&&3===v.filterHeight&&v.inChannels%4==0?I=new ct(v,b,h,k):(I=new ht(v,b,h,k),x.push({type:"int32",data:[v.filterHeight]},{type:"int32",data:[v.filterWidth]},{type:"int32",data:[v.outChannels/v.inChannels]})),"leakyrelu"===h&&(x.push({type:"float32",data:[f]}),I.uniforms+=" alpha : f32,"),r.runWebGPUProgram(I,g,"float32",x)}},Kt=function(){function e(e,n){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gathernd_"+e,this.sliceDim=e,this.uniforms="sliceDim : i32, strides : "+k(e)+","}return e.prototype.getUserCode=function(){return"\n        \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = "+(this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides")+";\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      "},e}();var Qt={kernelName:n.GatherNd,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=t.params,o=t.indices,a=o.shape,u=a[a.length-1],l=n.util.sizeFromShape(i.shape),d=s(n.backend_util.prepareAndValidate(i,o),4),p=d[0],c=d[1],h=d[2],f=d[3],m=V({inputs:{x:o},backend:r,attrs:{shape:[c,u]}}),v=V({inputs:{x:i},backend:r,attrs:{shape:[n.util.sizeFromShape(i.shape)/h,h]}});if(r.shouldExecuteOnCPU([i,o])||"string"===i.dtype){var g=r.readSync(o.dataId),b=r.bufferSync(i),k=Be(g,b,i.dtype,c,u,h,f,i.shape,l);return r.makeTensorInfo(p,i.dtype,k.values)}var I=new Kt(u,[c,h]),x=[{type:"int32",data:[u]},{type:"int32",data:f}],w=r.runWebGPUProgram(I,[v,m],v.dtype,x),y=V({inputs:{x:w},backend:r,attrs:{shape:p}});return r.disposeData(m.dataId),r.disposeData(v.dataId),r.disposeData(w.dataId),y}},Zt=function(){function e(e,n){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=n,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gather"}return e.prototype.getUserCode=function(){return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA("+function(e){for(var n=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[],r=0;r<e.length;r++)2===r?t.push("indexZ"):t.push(""+n[r]);return t.join()}(this.aShape)+"));\n        }\n      }\n    "},e}();function Jt(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=t.indices,u=i.axis,s=i.batchDims,l=n.util.parseAxisParam(u,o.shape)[0],d=n.backend_util.segment_util.collectGatherOpShapeInfo(o,a,l,s),p=n.util.sizeFromShape(a.shape),c=[],h=V({inputs:{x:o},backend:r,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),f=V({inputs:{x:a},backend:r,attrs:{shape:[d.batchSize,p/d.batchSize]}});c.push(h),c.push(f);var m=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize];if(r.shouldExecuteOnCPU([o,a])){var v=r.tensorMap.get(f.dataId).values,g=n.buffer(f.shape,f.dtype,v),b=r.tensorMap.get(h.dataId).values,k=n.buffer(h.shape,h.dtype,b),I=Le(k,g,m);return c.forEach((function(e){return r.disposeData(e.dataId)})),r.makeTensorInfo(d.outputShape,I.dtype,I.values)}var x=new Zt(h.shape,m),w=r.runWebGPUProgram(x,[h,f],h.dtype);c.push(w);var y=V({inputs:{x:w},backend:r,attrs:{shape:d.outputShape}});return c.forEach((function(e){return r.disposeData(e.dataId)})),y}var $t={kernelName:n.GatherV2,backendName:"webgpu",kernelFunc:Jt},er=ie({opSnippet:d.GREATER,cpuKernelImpl:Ee,dtype:"bool"}),nr={kernelName:n.Greater,backendName:"webgpu",kernelFunc:er},tr=ie({opSnippet:d.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:We}),rr={kernelName:n.GreaterEqual,backendName:"webgpu",kernelFunc:tr};var ir={kernelName:n.LeakyRelu,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,i=n.x,o=[{type:"float32",data:[r.alpha]}],a=new te(i.shape,c.LEAKYRELU);return a.uniforms="alpha : f32,",t.runWebGPUProgram(a,[i],"float32",o)}},or=ie({opSnippet:d.LESS,dtype:"bool",cpuKernelImpl:Fe}),ar={kernelName:n.Less,backendName:"webgpu",kernelFunc:or},ur=ie({opSnippet:d.LESS_EQUAL,dtype:"bool",cpuKernelImpl:Oe}),sr={kernelName:n.LessEqual,backendName:"webgpu",kernelFunc:ur},lr=re({opType:c.LOG,cpuKernelImpl:Ue}),dr={kernelName:n.Log,backendName:"webgpu",kernelFunc:lr},pr=ie({opSnippet:d.LOGICAL_AND,dtype:"bool"}),cr={kernelName:n.LogicalAnd,backendName:"webgpu",kernelFunc:pr},hr=re({opType:c.LOGICAL_NOT}),fr={kernelName:n.LogicalNot,backendName:"webgpu",kernelFunc:hr};function mr(e){var n=e.inputs,t=e.backend,r=e.attrs;return bt(n.x,r.reductionIndices,r.keepDims,"max",t)}var vr={kernelName:n.Max,backendName:"webgpu",kernelFunc:mr},gr=ie({opSnippet:d.MAX,cpuKernelImpl:Me}),br={kernelName:n.Maximum,backendName:"webgpu",kernelFunc:gr};var kr={kernelName:n.MaxPool,backendName:"webgpu",kernelFunc:function(e){var t,r=e.inputs,i=e.backend,o=e.attrs,a=r.x,u=o.filterSize,s=o.strides,l=o.pad,d=o.dimRoundingMode,p=n.backend_util.computePool2DInfo(a.shape,u,s,1,l,d),c=[];if(1===p.filterHeight&&1===p.filterWidth){if(n.util.arraysEqual(p.inShape,p.outShape))return J({inputs:{x:a},backend:i});t=new In(p),c.push({type:"int32",data:[p.strideHeight,p.strideWidth]})}else t=new kn(p,"max"),c.push({type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]});return i.runWebGPUProgram(t,[a],a.dtype,c)}};var Ir={kernelName:n.Mean,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,i=n.x,o=r.keepDims;return bt(i,r.axis,o,"mean",t)}};var xr={kernelName:n.Min,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs;return bt(n.x,r.axis,r.keepDims,"min",t)}},wr=ie({opSnippet:d.MIN,cpuKernelImpl:Ve}),yr={kernelName:n.Minimum,backendName:"webgpu",kernelFunc:wr},Sr=function(){function e(e,n,t){var r=this;this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((function(n,t){return n[0]+e[t]+n[1]})),this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.xShape=e,n.map((function(e,n){r.uniforms+=" pad"+n+" : vec2<i32>,"})),this.offset="reflect"===t?0:1,this.shaderKey="mirrorPad_"+t}return e.prototype.getUserCode=function(){var e=this.xShape.length,n=this.xShape.map((function(e,n){return"uniforms.pad"+n+"[0]"})).join(","),t=this.xShape.map((function(n,t){return"uniforms.pad"+t+"[0] + uniforms.xShape"+(e>1?"["+t+"]":"")})).join(","),r=1===e?"start":"start[i]",i=1===e?"end":"end[i]",o=1===e?"outC":"outC[i]",a=k(e),u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          let start = "+a+"("+n+");\n          let end = "+a+"("+t+");\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < "+e+"; i = i + 1) {\n            if ("+o+" < "+r+") {\n              "+o+" = "+r+" * 2 - "+o+" - "+this.offset+";\n            } else if("+o+" >= "+i+") {\n              "+o+" = ("+i+" - 1) * 2 - "+o+" + "+this.offset+";\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX("+u+"));\n        }\n      }\n    "},e}(),Cr={kernelName:n.MirrorPad,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.attrs,r=e.backend,i=n.x,o=t.paddings,a=t.mode,u=r,s=o.map((function(e){return{type:"int32",data:[e[0],e[1]]}})),l=new Sr(i.shape,o,a);return u.runWebGPUProgram(l,[i],i.dtype,s)}};var zr={kernelName:n.Neg,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=n.x;if(t.shouldExecuteOnCPU([r])){var i=t.tensorMap.get(r.dataId),o=s(He(i.values,r.shape,r.dtype),2),a=o[0],u=o[1];return t.makeTensorInfo(u,r.dtype,a)}var l=new te(r.shape,c.NEG);return t.runWebGPUProgram(l,[r],r.dtype)}};var _r={kernelName:n.NonMaxSuppressionV3,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var t=e.inputs,r=e.backend,i=e.attrs,o=t.boxes,a=t.scores,u=i.maxOutputSize,s=i.iouThreshold,l=i.scoreThreshold,d=r.readSync(o.dataId),p=r.readSync(a.dataId),c=n.kernel_impls.nonMaxSuppressionV3Impl(d,p,u,s,l).selectedIndices;return r.makeTensorInfo([c.length],"int32",new Int32Array(c))}};var Gr={kernelName:n.NonMaxSuppressionV5,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var t=e.inputs,r=e.backend,i=e.attrs,o=t.boxes,a=t.scores,u=i.maxOutputSize,s=i.iouThreshold,l=i.scoreThreshold,d=i.softNmsSigma,p=r.readSync(o.dataId),c=r.readSync(a.dataId),h=u,f=s,m=l,v=d,g=n.kernel_impls.nonMaxSuppressionV5Impl(p,c,h,f,m,v),b=g.selectedIndices,k=g.selectedScores;return[r.makeTensorInfo([b.length],"int32",new Int32Array(b)),r.makeTensorInfo([k.length],"float32",new Float32Array(k))]}};function Ar(e){var n=e.inputs,t=e.backend,r=n.x;if("complex64"===r.dtype){var i=Tn({inputs:{input:r},backend:t}),o=Ar({inputs:{x:i},backend:t}),a=Fn({inputs:{input:r},backend:t}),u=Ar({inputs:{x:a},backend:t}),s=ee({inputs:{real:o,imag:u},backend:t});return t.disposeData(i.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),t.disposeData(u.dataId),s}return Nt({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:t})}var Tr={kernelName:n.ZerosLike,backendName:"webgpu",kernelFunc:Ar};var Rr={kernelName:n.OnesLike,backendName:"webgpu",kernelFunc:function e(n){var t=n.inputs,r=n.backend,i=t.x;if("string"===i.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===i.dtype){var o=Tn({inputs:{input:i},backend:r}),a=e({inputs:{x:o},backend:r}),u=Fn({inputs:{input:i},backend:r}),s=Ar({inputs:{x:u},backend:r}),l=ee({inputs:{real:a,imag:s},backend:r});return r.disposeData(o.dataId),r.disposeData(a.dataId),r.disposeData(u.dataId),r.disposeData(s.dataId),l}return Nt({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:r})}};var Pr={kernelName:n.Pack,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs.axis;if(1===t.length)return Gt({inputs:{input:t[0]},backend:r,attrs:{dim:i}});var o=t[0].shape,a=t[0].dtype;t.forEach((function(e){n.util.assertShapesMatch(o,e.shape,"All tensors passed to stack must have matching shapes"),n.util.assert(a===e.dtype,(function(){return"All tensors passed to stack must have matching dtypes"}))}));var u=[],s=Mn({inputs:t.map((function(e){var n=Gt({inputs:{input:e},backend:r,attrs:{dim:i}});return u.push(n),n})),backend:r,attrs:{axis:i}});return u.forEach((function(e){return r.disposeData(e.dataId)})),s}},Nr=function(){function e(e,n){var t=this;this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((function(n,t){return n[0]+e[t]+n[1]})),this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),n.map((function(e,n){t.uniforms+=" pad"+n+" : vec2<i32>,"})),this.xShape=e,this.shaderKey="pad"}return e.prototype.getUserCode=function(){var e=this.xShape.length,n=k(e),t=this.xShape.map((function(e,n){return"uniforms.pad"+n+"[0]"})).join(","),r=this.xShape.map((function(n,t){return"uniforms.pad"+t+"[0] + uniforms.xShape"+(e>1?"["+t+"]":"")})).join(",");return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          let start = "+(e>1?n+"("+t+")":""+t)+";\n          let end = "+(e>1?n+"("+r+")":""+r)+";\n          let outC = getCoordsFromIndex(index);\n\n          if ("+(e>1?"any(outC < start)":"outC < start")+" || "+(e>1?"any(outC >= end)":"outC >= end")+") {\n            setOutputAtIndex(index, uniforms.constantValue);\n          } else {\n            let coords = outC - start;\n            setOutputAtIndex(index, getX("+(e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords")+"));\n          }\n        }\n      }\n    "},e}(),Br=function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=i.paddings,u=i.constantValue;if(a.every((function(e){return n.util.arraysEqual(e,[0,0])})))return J({inputs:{x:o},backend:r});if(0===n.util.sizeFromShape(o.shape))return Nt({backend:r,attrs:{shape:a.map((function(e,n){return e[0]+o.shape[n]+e[1]})),value:u,dtype:o.dtype}});var s=[{type:"float32",data:[u]}];a.map((function(e){return s.push({type:"int32",data:[e[0],e[1]]})}));var l=new Nr(o.shape,a);return r.runWebGPUProgram(l,[o],o.dtype,s)},Lr={kernelName:n.PadV2,backendName:"webgpu",kernelFunc:Br},Wr=ie({opSnippet:d.POW}),Er={kernelName:n.Pow,backendName:"webgpu",kernelFunc:Wr};var Or={kernelName:n.Prelu,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=n.x,i=n.alpha,o=new Q(d.PRELU,r.shape,i.shape);return t.runWebGPUProgram(o,[r,i],"float32")}};var Fr={kernelName:n.Prod,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs;return bt(n.x,r.axis,r.keepDims,"prod",t)}},Ur={kernelName:n.Range,backendName:"webgpu",kernelFunc:function(e){var n=e.backend,t=e.attrs,r=t.start,i=t.stop,o=t.step,a=t.dtype,u=je(r,i,o,a);return n.makeTensorInfo([u.length],a,u)}},Dr=ie({opSnippet:d.DIV}),Mr={kernelName:n.RealDiv,backendName:"webgpu",kernelFunc:Dr},Vr=re({opType:c.RELU}),Xr={kernelName:n.Relu,backendName:"webgpu",kernelFunc:Vr},Hr=re({opType:c.RELU6}),Yr={kernelName:n.Relu6,backendName:"webgpu",kernelFunc:Hr},qr=function(){function e(e,n,t){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,t,e[3]],this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="resizeBilinear"}return e.prototype.getUserCode=function(){return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    "},e}();var jr={kernelName:n.ResizeBilinear,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,i=n.images,o=r.alignCorners,a=r.size,u=r.halfPixelCenters,l=s(a,2),d=l[0],p=l[1],c=[{type:"float32",data:[o&&d>1?1:0,o&&p>1?1:0]},{type:"float32",data:[u?.5:0]}],h=new qr(i.shape,d,p);return t.runWebGPUProgram(h,[i],"float32",c)}},Kr=function(){function e(e,n,t,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,t,e[3]],this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.halfPixelCenters=r,this.shaderKey="resizeNearest_"+r}return e.prototype.getUserCode=function(){return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = "+(this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC")+";\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    "},e}();var Qr={kernelName:n.ResizeNearestNeighbor,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,i=n.images,o=r.alignCorners,a=r.halfPixelCenters,u=s(r.size,2),l=u[0],d=u[1],p=[{type:"float32",data:[o&&l>1?1:0,o&&d>1?1:0]},{type:"float32",data:[o?.5:0]}],c=new Kr(i.shape,l,d,a);return t.runWebGPUProgram(c,[i],i.dtype,p)}},Zr=function(){function e(e,n){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof n?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}return e.prototype.getUserCode=function(){return"\n        \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            "+this.fillSnippet+"\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      "},e}(),Jr={kernelName:n.RotateWithOffset,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.attrs,i=e.backend,o=t.image,a=r.radians,u=r.fillValue,l=r.center,d=i,p=new Zr(o.shape,u),c=s(n.backend_util.getImageCenter(l,o.shape[1],o.shape[2]),2),h=[{type:"float32",data:[c[0]]},{type:"float32",data:[c[1]]},{type:"float32",data:[Math.sin(a)]},{type:"float32",data:[Math.cos(a)]}];return"number"==typeof u?h.push({type:"float32",data:[Number.parseFloat(u.toFixed(2))]}):h.push({type:"float32",data:u}),d.runWebGPUProgram(p,[o],o.dtype,h)}},$r=re({opType:c.RSQRT,cpuKernelImpl:Ke}),ei={kernelName:n.Rsqrt,backendName:"webgpu",kernelFunc:$r},ni=function(){function e(e,n,t,r,i,o,a){this.variableNames=["updates","indices"],this.workGroupSize=[64,1,1],this.atomic=!0,this.outputShape=o,this.type=a,this.dispatchLayout=P(e),this.dispatch=G(this.dispatchLayout,e,this.workGroupSize),this.sliceDimGreaterThanOne=n>1,this.shaderKey="scatter_"+t+"_"+r+"_"+this.sliceDimGreaterThanOne+"_"+a;var u=k(i.length);this.uniforms="sliceDim : i32, strides: "+u+", size: i32,",this.updatesRank=r,this.indicesRank=t}return e.prototype.getUserCode=function(){var e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");var n="getIndices("+e+")",t=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides",r="",i="",o="";return 1===this.updatesRank?(r="coords[0]",i="flattenedIndex",o="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.updatesRank&&(r="coords[0], coords[1]",i="vec2<i32>(flattenedIndex, coords[1])",o="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        let d0 = index / uniforms.updatesShape[1];\n        let d1 = index - d0 * uniforms.updatesShape[1];\n        return vec2<i32>(d0, d1);\n      }\n      "),"\n    "+o+"\n\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n\n        if (index < uniforms.size) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round("+n+"));\n            flattenedIndex = flattenedIndex + indexInside * "+t+";\n          }\n          let updateValue = "+("getUpdates("+r+")")+";\n          let flatIndex = getOutputIndexFromCoords("+i+");\n\n         "+("int32"===this.type?"atomicAdd(&(result[flatIndex]), i32(updateValue));":"\n     var assumed = atomicLoad(&(result[flatIndex]));\n     var success = 0;\n     for (; success == 0;) {\n       let new = bitcast<f32>(assumed) + updateValue;\n       let newI32 = bitcast<i32>(new);\n       let resValue = atomicCompareExchangeWeak(&(result[flatIndex]), assumed, newI32);\n       assumed = resValue[0];\n       success = resValue[1];\n     }\n     ")+"\n        }\n      }"},e}();var ti={kernelName:n.ScatterNd,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.indices,a=t.updates,u=i.shape,s=n.backend_util.calculateShapes(a,o,u),l=s.sliceRank,d=s.numUpdates,p=s.sliceSize,c=s.strides,h=s.outputSize,f=[h/p,p];if(0===h)return r.makeTensorInfo(u,o.dtype);var m=V({inputs:{x:o},backend:r,attrs:{shape:[d,l]}}),v=V({inputs:{x:a},backend:r,attrs:{shape:[d,p]}}),g=v.dtype,b=Nt({backend:r,attrs:{shape:f,value:0,dtype:g}}),k=[{type:"int32",data:[l]},{type:"int32",data:c},{type:"int32",data:[n.util.sizeFromShape(v.shape)]}],I=new ni(v.shape,l,m.shape.length,v.shape.length,c,f,g),x=r.runWebGPUProgram(I,[v,m],g,k,b),w=V({inputs:{x:x},backend:r,attrs:{shape:u}});return r.disposeData(m.dataId),r.disposeData(v.dataId),r.disposeData(x.dataId),w}},ri=function(){function e(e,n,t){this.variableNames=["c","a","b"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.cRank=e,this.rank=t,this.shaderKey="select"}return e.prototype.getUserCode=function(){var e,n;if(this.rank>4)throw Error("Where for rank "+this.rank+" is not yet supported");if(1===this.rank)n="resRC",e="resRC";else{for(var t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],i=[],o=0;o<this.outputShape.length;o++)i.push(""+t[o]),o<this.cRank&&r.push(""+t[o]);e=r.join(),n=i.join()}return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC("+e+");\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA("+n+"));\n          } else {\n            setOutputAtIndex(index, getB("+n+"));\n          }\n        }\n      }\n    "},e}();var ii={kernelName:n.Select,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=t.condition,o=t.t,a=t.e,u=new ri(i.shape.length,o.shape,o.shape.length);return r.runWebGPUProgram(u,[i,o,a],n.upcastType(o.dtype,a.dtype))}},oi=re({opType:c.SIGMOID}),ai={kernelName:n.Sigmoid,backendName:"webgpu",kernelFunc:oi},ui=re({opType:c.SIN}),si={kernelName:n.Sin,backendName:"webgpu",kernelFunc:ui},li=re({opType:c.SINH}),di={kernelName:n.Sinh,backendName:"webgpu",kernelFunc:li},pi=ie({opSnippet:d.SUB,cpuKernelImpl:nn,supportsComplex:!0}),ci={kernelName:n.Sub,backendName:"webgpu",kernelFunc:pi};var hi={kernelName:n.Softmax,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.logits,a=i.dim,u=n.util.parseAxisParam([a],o.shape),s=mr({inputs:{x:o},backend:r,attrs:{reductionIndices:u,keepDims:!1}}),l=n.backend_util.expandShapeToKeepDim(s.shape,u),d=V({inputs:{x:s},backend:r,attrs:{shape:l}}),p=pi({inputs:{a:o,b:d},backend:r}),c=zt({inputs:{x:p},backend:r}),h=kt({inputs:{x:c},backend:r,attrs:{axis:u,keepDims:!1}}),f=V({inputs:{x:h},backend:r,attrs:{shape:l}}),m=Dr({inputs:{a:c,b:f},backend:r});return r.disposeData(s.dataId),r.disposeData(d.dataId),r.disposeData(p.dataId),r.disposeData(c.dataId),r.disposeData(h.dataId),r.disposeData(f.dataId),m}},fi={kernelName:n.SpaceToBatchND,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=i.blockShape,u=i.paddings;n.util.assert(o.shape.length<=4,(function(){return"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"}));var s=a.reduce((function(e,n){return e*n})),d=[[0,0]];d.push.apply(d,l(u));for(var p=1+a.length;p<o.shape.length;++p)d.push([0,0]);var c=[],h=Br({inputs:{x:o},backend:r,attrs:{paddings:d,constantValue:0}}),f=n.backend_util.getReshaped(h.shape,a,s,!1),m=n.backend_util.getPermuted(f.length,a.length,!1),v=n.backend_util.getReshapedPermuted(h.shape,a,s,!1),g=V({inputs:{x:h},backend:r,attrs:{shape:f}}),b=mn({inputs:{x:g},backend:r,attrs:{perm:m}}),k=V({inputs:{x:b},backend:r,attrs:{shape:v}});return c.push(h),c.push(g),c.push(b),c.forEach((function(e){return r.disposeData(e.dataId)})),k}},mi=function(){function e(e,n,t,r,i,o,a){this.variableNames=["updates","indices","defaultValue"],this.workGroupSize=[64,1,1],this.workPerThread=4,this.size=!0,this.outputShape=o,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);var u=n>1;this.shaderKey="scatter_"+t+"_"+r+"_"+u;var s=k(i.length);this.uniforms="updateSize : i32, sliceDim : i32, strides: "+s+",";var l="";1===t?l="i":2===t&&(l="i, j"),this.indicesSnippet="getIndices("+l+")";var d="";1===r?d="i":2===r&&(d="i, coords[1]"),this.updatesSnippet="getUpdates("+d+")",this.strideString=u?"uniforms.strides[j]":"uniforms.strides"}return e.prototype.getUserCode=function(){return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n\n        let globalIndex = index * "+this.workPerThread+";\n        if (globalIndex < uniforms.size) {\n          var sum = vec4<f32>(0.0);\n          var found = vec4<bool>(false);\n          for (var i = 0; i < uniforms.updateSize; i = i + 1) {\n            var flattenedIndex = 0;\n            for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n              let indexInside = i32(round("+this.indicesSnippet+"));\n              flattenedIndex = flattenedIndex + indexInside * "+this.strideString+";\n            }\n            for (var innerIndex = 0; innerIndex < "+this.workPerThread+"; innerIndex = innerIndex + 1) {\n              let curIndex = globalIndex + innerIndex;\n              let coords = getCoordsFromIndex(curIndex);\n              if (flattenedIndex == coords[0]) {\n                sum[innerIndex] = sum[innerIndex] + "+this.updatesSnippet+";\n                found[innerIndex] = true;\n              }\n            }\n          }\n          for (var innerIndex = 0; innerIndex < "+this.workPerThread+"; innerIndex = innerIndex + 1) {\n            let curIndex = globalIndex + innerIndex;\n            if (curIndex < uniforms.size)\n            {\n              setOutputAtIndex(curIndex, mix(getDefaultValue(), sum[innerIndex], f32(found[innerIndex])));\n            }\n          }\n        }\n      }"},e}();var vi={kernelName:n.SparseToDense,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.sparseIndices,a=t.sparseValues,u=t.defaultValue,s=i.outputShape,l=n.backend_util.calculateShapes(a,o,s),d=l.sliceRank,p=l.numUpdates,c=l.sliceSize,h=l.strides,f=l.outputSize;if("string"===a.dtype){var m=r.bufferSync(o),v=r.bufferSync(a),g=n.util.decodeString(r.readSync(u.dataId)[0]),b=Qe(m,v,s,f,c,p,d,h,g,false);return r.makeTensorInfo(s,b.dtype,b.values)}var k=[{type:"int32",data:[p]},{type:"int32",data:[d]},{type:"int32",data:h}],I=new mi(p,d,o.shape.length,a.shape.length,h,[f,1],false),x=r.runWebGPUProgram(I,[a,o,u],a.dtype,k),w=V({inputs:{x:x},backend:r,attrs:{shape:s}});return r.disposeData(x.dataId),w}};var gi={kernelName:n.SplitV,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=i.numOrSizeSplits,u=i.axis,s=n.util.parseAxisParam(u,o.shape)[0],d=n.backend_util.prepareSplitSize(o,a,s),p=o.shape.length,c=new Array(p).fill(0),h=o.shape.slice();return d.map((function(e){var n=l(h);n[s]=e;var t=Cn({inputs:{x:o},backend:r,attrs:{begin:c,size:n}});return c[s]+=e,t}))}},bi=re({opType:c.SQRT}),ki={kernelName:n.Sqrt,backendName:"webgpu",kernelFunc:bi},Ii={kernelName:n.Square,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=n.x,i=t,o=new te(r.shape,c.SQUARE);return i.runWebGPUProgram(o,[r],r.dtype)}},xi=ie({opSnippet:d.SQUARED_DIFFERENCE}),wi={kernelName:n.SquaredDifference,backendName:"webgpu",kernelFunc:xi},yi=function(){function e(e){this.variableNames=["x"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);var n=k(this.outputShape.length);this.uniforms="begin : "+n+",  strides : "+n+", ",this.shaderKey="stridedSlice"}return e.prototype.getUserCode=function(){var e=this,n="";if(1===this.outputShape.length)n="coords * uniforms.strides + uniforms.begin";else{var t=0;n=this.outputShape.map((function(n,r){return t++,1===e.outputShape.length?"coords * uniforms.strides["+r+"] + uniforms.begin["+r+"]":"coords["+(t-1)+"] * uniforms.strides["+r+"] + uniforms.begin["+r+"]"})).join(",")}return"\n       \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX("+n+"));\n         }\n       }\n     "},e}();var Si={kernelName:n.StridedSlice,backendName:"webgpu",kernelFunc:function(e){var t,r=e.inputs,i=e.backend,o=e.attrs,a=r.x,u=o.begin,s=o.end,l=o.strides,d=o.beginMask,p=o.endMask,c=o.ellipsisMask,h=o.newAxisMask,f=o.shrinkAxisMask,m=n.slice_util.sliceInfo(a.shape,u,s,l,d,p,c,h,f),v=m.finalShapeSparse,g=m.finalShape,b=m.isIdentity,k=m.sliceDim0,I=m.isSimpleSlice,x=m.begin,w=m.end,y=m.strides;if(b)t=V({inputs:{x:a},backend:i,attrs:{shape:g}});else if(k||I){n.util.assert(a.shape.length>=1,(function(){return"Input must have rank at least 1, got: "+a.shape.length}));var S=n.slice_util.computeOutShape(x,w,y),C=Cn({inputs:{x:a},backend:i,attrs:{begin:x,size:S}});t=V({inputs:{x:C},backend:i,attrs:{shape:g}}),i.disposeData(C.dataId)}else{if(i.shouldExecuteOnCPU([a])){var z=i.readSync(a.dataId),_=n.buffer(a.shape,a.dtype,z),G=$e(v,_,y,x);t=i.makeTensorInfo(g,a.dtype,G.values)}else{var A=new yi(v),T=[{type:"int32",data:x},{type:"int32",data:y}];t=V({inputs:{x:G=i.runWebGPUProgram(A,[a],a.dtype,T)},backend:i,attrs:{shape:g}}),i.disposeData(G.dataId)}}return t}};var Ci={kernelName:n.StringNGrams,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,i=r.separator,o=r.nGramWidths,a=r.leftPad,u=r.rightPad,l=r.padWidth,d=r.preserveShortSequences,p=n.data,c=n.dataSplits,h=t.readSync(p.dataId),f=t.readSync(c.dataId),m=s(en(h,f,i,o,a,u,l,d),2),v=m[0],g=m[1];return[t.makeTensorInfo([v.length],"string",v),t.makeTensorInfo(c.shape,"int32",g)]}},zi=re({opType:c.TANH}),_i={kernelName:n.Tanh,backendName:"webgpu",kernelFunc:zi},Gi=function(){function e(e,n){this.variableNames=["A"],this.workGroupSize=[64,1,1],this.size=!0;for(var t=new Array(e.length),r=0;r<t.length;r++)t[r]=e[r]*n[r];this.outputShape=t,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}return e.prototype.getUserCode=function(){return"\n      \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA("+function(e,n){void 0===n&&(n="");if(e>=5)throw Error("Tile for rank "+e+" is not yet supported");if(1===e)return"(resRC % "+n+"aShape)";for(var t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],i=0;i<e;i++)r.push("("+t[i]+" % "+n+"aShape["+i+"])");return r.join()}(this.rank,"uniforms.")+"));\n        }\n      }\n    "},e}();var Ai={kernelName:n.Tile,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=i.reps;if(r.shouldExecuteOnCPU([o])||"string"===o.dtype||o.shape.length>=5){var u=r.readSync(o.dataId),s="string"===o.dtype?u.map((function(e){return n.util.decodeString(e)})):u,l=n.buffer(o.shape,o.dtype,s),d=tn(l,a);return r.makeTensorInfo(d.shape,d.dtype,d.values)}var p=new Gi(o.shape,a);return r.runWebGPUProgram(p,[o],o.dtype)}},Ti=function(){function e(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}return e.prototype.getUserCode=function(){return"\n        \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      "},e}(),Ri=function(){function e(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}return e.prototype.getUserCode=function(){return"\n        \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      "},e}();function Pi(e,n){null!==n&&e.disposeData(n.dataId)}function Ni(e){for(var n=1;n<e;)n*=2;return n}var Bi={kernelName:n.TopK,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,r=e.backend,i=e.attrs,o=t.x,a=i.k,u=i.sorted,l=o.shape,d=l[l.length-1];if(r.shouldExecuteOnCPU([o])){var p=r.readSync(o.dataId),c=s(rn(p,l,o.dtype,a,u),2),h=c[0],f=c[1];return[r.makeTensorInfo(h.shape,h.dtype,h.values),r.makeTensorInfo(f.shape,f.dtype,f.values)]}if(0===a)return l[l.length-1]=0,[r.makeTensorInfo(l,o.dtype,[]),r.makeTensorInfo(l,"int32",[])];if(1===d)return[o,Nt({attrs:{shape:l,dtype:"int32",value:0},backend:r})];for(var m=n.util.sizeFromShape(l)/d,v=V({inputs:{x:o},attrs:{shape:[m,d]},backend:r}),g=Ni(a),b=Ni(d),k=null,I=function(){return null===k?[v,v]:[v,k]},x=function(e,n,t){var i=I(),o=new Ti(t),a=[{type:"int32",data:[d]},{type:"int32",data:[null===k?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[n]}],u=k;k=r.runWebGPUProgram(o,i,"int32",a),Pi(r,u)},w=1;w<g;w*=2)for(var y=2*w,S=w;S>=1;S/=2)x(y,S,[m,b]);for(var C=b;C>g;C/=2){var z=I(),_=new Ri([m,C/2]),G=[{type:"int32",data:[d]},{type:"int32",data:[null===k?1:0]},{type:"int32",data:[g]}],A=k;k=r.runWebGPUProgram(_,z,"int32",G),Pi(r,A);for(y=2*(w=g/2),S=w;S>=1;S/=2)x(y,S,k.shape)}var T=k;k=Cn({inputs:{x:k},backend:r,attrs:{begin:0,size:[m,a]}}),Pi(r,T);var R=Jt({inputs:{x:v,indices:k},backend:r,attrs:{axis:1,batchDims:1}});Pi(r,v);var P=l.slice(0,-1);P.push(a),T=k,k=V({inputs:{x:k},attrs:{shape:P},backend:r}),Pi(r,T);var N=R;return R=V({inputs:{x:R},attrs:{shape:P},backend:r}),Pi(r,N),[R,k]}},Li=function(){function e(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=P(this.outputShape),this.dispatch=G(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="transform"}return e.prototype.getUserCode=function(){return"\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          \n    \n  \n  @stage(compute) @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n  fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,\n          @builtin(global_invocation_id) GlobalId : vec3<u32>,\n          @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n      let index = getGlobalIndex();\n\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        "},e}();var Wi,Ei,Oi=[Y,un,ln,pn,gn,bn,xn,wn,_n,Pn,Bn,En,ne,Vn,qn,Zn,$n,nt,rt,st,lt,pt,ft,xt,yt,Ct,_t,At,Rt,Lt,Et,Vt,Ft,Dt,Yt,qt,jt,Qt,$t,nr,rr,$,Un,ir,ar,sr,dr,cr,fr,vr,br,kr,Ir,xr,yr,Cr,vt,zr,_r,Gr,An,Rr,Pr,Lr,Er,Or,Fr,Ur,Rn,Mr,Xr,Yr,X,jr,Qr,Jr,ei,ti,ii,ai,si,di,zn,Si,Ci,hi,fi,vi,gi,ki,Ii,wi,ci,It,_i,Ai,Bi,{kernelName:n.Transform,backendName:"webgpu",kernelFunc:function(e){var n,t=e.inputs,r=e.backend,i=e.attrs,o=t.image,a=t.transforms,u=i.interpolation,l=i.fillMode,d=i.fillValue,p=i.outputShape,c=s(o.shape,4),h=c[0],f=c[1],m=c[2],v=c[3],g=s(null!=p?p:[f,m],2),b=g[0],k=g[1],I=new Li([h,b,k,v]),x="nearest"===u?1:2;switch(l){case"constant":n=1;break;case"reflect":n=2;break;case"wrap":n=3;break;case"nearest":n=4;break;default:n=1}var w=[{type:"int32",data:[x]},{type:"int32",data:[n]},{type:"float32",data:[d]}];return r.runWebGPUProgram(I,[o,a],"float32",w)}},vn,{kernelName:n.Unpack,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,i=n.value,o=r.axis;o<0&&(o+=i.shape.length);for(var a=i,u=a.shape.length,s=i.shape[o],l=new Array(u-1),d=0,p=0;p<u;p++)p!==o&&(l[d++]=a.shape[p]);var c=[],h=new Array(u).fill(0),f=a.shape.slice();f[o]=1;var m=new Array(s);for(p=0;p<m.length;p++){h[o]=p;var v=Cn({inputs:{x:a},backend:t,attrs:{begin:h,size:f}}),g=V({inputs:{x:v},backend:t,attrs:{shape:l}});m[p]=g,c.push(v)}return c.forEach((function(e){return t.disposeData(e.dataId)})),m}},Tr];try{for(var Fi=u(Oi),Ui=Fi.next();!Ui.done;Ui=Fi.next()){var Di=Ui.value;n.registerKernel(Di)}}catch(e){Wi={error:e}}finally{try{Ui&&!Ui.done&&(Ei=Fi.return)&&Ei.call(Fi)}finally{if(Wi)throw Wi.error}}var Mi=function(){function e(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}return e.prototype.acquireUploadBuffer=function(e,n){return this.acquireBuffer(e,n,!0)},e.prototype.acquireBuffer=function(e,n,t){void 0===t&&(t=!1);var r=Vi(e,n);if(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(r).length>0){this.numFreeBuffers--;var i=this.freeBuffers.get(r).shift();return this.usedBuffers.get(r).push(i),i}this.numBytesAllocated+=e;var o=this.device.createBuffer({mappedAtCreation:t,size:e,usage:n});return this.usedBuffers.get(r).push(o),o},e.prototype.releaseBuffer=function(e,n,t){if(0!==this.freeBuffers.size){var r=Vi(n,t);this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).push(e),this.numFreeBuffers++,this.numUsedBuffers--;var i=this.usedBuffers.get(r),o=i.indexOf(e);if(o<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");i.splice(o,1),this.numBytesUsed-=n}},e.prototype.releaseUploadBuffer=function(e,n,t){var r=this;e.mapAsync(GPUMapMode.WRITE).then((function(){r.releaseBuffer(e,n,t)}),(function(e){}))},e.prototype.getNumUsedBuffers=function(){return this.numUsedBuffers},e.prototype.getNumFreeBuffers=function(){return this.numFreeBuffers},e.prototype.dispose=function(){this.freeBuffers.forEach((function(e,n){e.forEach((function(e){e.destroy()}))})),this.usedBuffers.forEach((function(e,n){e.forEach((function(e){e.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0},e}();function Vi(e,n){return e+"_"+n}var Xi=function(){function e(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}return e.prototype.acquireTexture=function(e,n,t,r){var i=e*n*Yi(t),o=Hi(e,n,t,r);if(this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.usedTextures.has(o)||this.usedTextures.set(o,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(o).length>0){this.numFreeTextures--;var a=this.freeTextures.get(o).shift();return this.usedTextures.get(o).push(a),a}this.numBytesAllocated+=i;var u=this.device.createTexture({size:[e,n],format:t,usage:r});return this.usedTextures.get(o).push(u),u},e.prototype.releaseTexture=function(e,n,t,r,i){if(0!==this.freeTextures.size){var o=Hi(n,t,r,i);this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.freeTextures.get(o).push(e),this.numFreeTextures++,this.numUsedTextures--;var a=this.usedTextures.get(o),u=a.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(u,1);var s=n*t*Yi(r);this.numBytesUsed-=s}},e.prototype.getNumUsedTextures=function(){return this.numUsedTextures},e.prototype.getNumFreeTextures=function(){return this.numFreeTextures},e.prototype.dispose=function(){this.freeTextures.forEach((function(e,n){e.forEach((function(e){e.destroy()}))})),this.usedTextures.forEach((function(e,n){e.forEach((function(e){e.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0},e}();function Hi(e,n,t,r){return e+"_"+n+"_"+t+"_"+r}function Yi(e){if("rgba8unorm"===e)return 16;throw new Error(e+" is not supported!")}var qi=function(e,n,t,r,i,o){void 0===o&&(o=!1);var a=w(r,{dtype:i.dtype,shape:i.shape},n,o),u=e.createShaderModule({code:a,label:n.constructor.name});return e.createComputePipeline({layout:t,compute:{module:u,entryPoint:"main"},label:n.constructor.name})};function ji(e,n,t,r,i){return void 0===t&&(t=[]),void 0===r&&(r=""),void 0===i&&(i=""),e.shaderKey+"_"+(e.workGroupSize?e.workGroupSize.join(","):"")+n.map((function(e){return e.length})).join(",")+t.join(",")+e.variableNames.join(",")+r+i}var Ki=n.env().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),Qi=function(e,t){var r=e.limits.maxComputeWorkgroupsPerDimension,i=t.dispatchLayout,o=t.dispatch;if(o.every((function(e){return e<=r})))return o;n.util.assert(o[0]>r&&void 0===i.y&&void 0===i.z,(function(){return"Dispatch size exceeds WebGPU limits in Y or Z dimension."}));var a=Math.ceil(Math.sqrt(o[0]));return a>r?(a=Math.ceil(Math.cbrt(o[0])),n.util.assert(a<=r,(function(){return"Total dispatch size exceeds WebGPU maximum."})),[a,a,a]):[a,a,1]},Zi=function(e){function t(t,r){void 0===r&&(r=!1);var i=e.call(this)||this;if(i.commandQueueOwnedIds=new WeakSet,i.tensorDisposalQueue=[],i.uniformDisposalQueue=[],i.stagingDisposalQueue=[],i.textureDisposalQueue=[],i.disposed=!1,i.uploadWaitMs=0,i.downloadWaitMs=0,i.dispatchNumberInEncoder=0,i.fromPixelTextureLayout=null,i.fromPixelImportTextureLayout=null,!L())throw new Error("WebGPU is not supported on this device");return i.layoutCache={},i.pipelineCache={},i.device=t,i.queue=t.queue,i.currentCommandEncoder=null,i.currentComputePass=null,i.supportTimeQuery=r,i.bufferManager=new Mi(i.device),i.textureManager=new Xi(i.device),i.tensorMap=new n.DataStorage(i,n.engine()),i.supportTimeQuery&&(i.querySet=i.device.createQuerySet({type:"timestamp",count:2})),n.env().getBool("WEBGPU_USE_PROFILE_TOOL")&&(i.dummyCanvas=document.createElement("canvas"),i.dummyCanvas.width=1,i.dummyCanvas.height=1,i.dummyContext=i.dummyCanvas.getContext("webgpu"),i.dummyContext.configure({device:t,format:"bgra8unorm"}),document.body.appendChild(i.dummyCanvas)),i}return function(e,n){function t(){this.constructor=e}i(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}(t,e),t.prototype.nextDataId=function(){return t.nextDataId++},t.prototype.floatPrecision=function(){return 32},t.prototype.defaultGpuBufferUsage=function(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST},t.prototype.flushDisposalQueue=function(){var e=this;this.tensorDisposalQueue.forEach((function(n){e.maybeReleaseBuffer(n),e.tensorMap.delete(n)})),this.uniformDisposalQueue.forEach((function(n){return e.bufferManager.releaseBuffer(n.buffer,n.byteSize,n.usage)})),this.stagingDisposalQueue.forEach((function(n){return e.bufferManager.releaseUploadBuffer(n.buffer,n.byteSize,n.usage)})),this.textureDisposalQueue.forEach((function(n){return e.textureManager.releaseTexture(n.texture,n.width,n.height,n.format,n.usage)})),this.tensorDisposalQueue=[],this.uniformDisposalQueue=[],this.stagingDisposalQueue=[],this.textureDisposalQueue=[]},t.prototype.disposeData=function(e,n){if(void 0===n&&(n=!1),this.tensorMap.has(e)){var t=this.tensorMap.get(e);if(t.refCount--,!n&&t.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDisposalQueue.push(e),!1;this.maybeReleaseBuffer(e);var r=this.tensorMap.get(e).complexTensorInfos;null!=r&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.tensorMap.delete(e)}return!0},t.prototype.memory=function(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}},t.prototype.getBufferManager=function(){return this.bufferManager},t.prototype.getTextureManager=function(){return this.textureManager},t.prototype.acquireBuffer=function(e,n){return void 0===n&&(n=this.defaultGpuBufferUsage()),this.bufferManager.acquireBuffer(e,n)},t.prototype.maybeReleaseBuffer=function(e){var n=this.tensorMap.get(e);null!=n&&null!=n.bufferInfo.buffer&&(this.bufferManager.releaseBuffer(n.bufferInfo.buffer,n.bufferInfo.byteSize,n.bufferInfo.usage),n.bufferInfo.buffer=null)},t.prototype.refCount=function(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0},t.prototype.incRef=function(e){this.tensorMap.get(e).refCount++},t.prototype.decRef=function(e){this.tensorMap.has(e)&&this.tensorMap.get(e).refCount--},t.prototype.write=function(e,t,r){if("complex64"===r&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var i={id:this.nextDataId()},o=n.util.sizeFromShape(t)*N(r);return this.tensorMap.set(i,{dtype:r,shape:t,values:e,bufferInfo:{byteSize:o,usage:this.defaultGpuBufferUsage()},refCount:1}),i},t.prototype.move=function(e,t,r,i,o){if("complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var a=n.util.sizeFromShape(r)*N(i);this.tensorMap.set(e,{dtype:i,shape:r,values:t,bufferInfo:{byteSize:a,usage:this.defaultGpuBufferUsage()},refCount:o})},t.prototype.submitQueue=function(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.flushDisposalQueue()},t.prototype.getBuffer=function(e){return this.uploadToGPU(e),this.tensorMap.get(e).bufferInfo.buffer},t.prototype.ensureCommandEncoderReady=function(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())},t.prototype.ensureComputePassEnded=function(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)},t.prototype.getComputePass=function(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass},t.prototype.getBufferData=function(e,t){return o(this,void 0,void 0,(function(){var r,i;return a(this,(function(o){switch(o.label){case 0:return r=this.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),[4,r.mapAsync(GPUMapMode.READ)];case 1:return o.sent(),i=r.getMappedRange().slice(0),r.unmap(),null!=r&&this.bufferManager.releaseBuffer(r,t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),n.env().getBool("WEBGPU_USE_PROFILE_TOOL")&&(n.util.assert(void 0!==this.dummyContext,(function(){return"Fail to get context for profiling tool"})),this.dummyContext.getCurrentTexture()),[2,i]}}))}))},t.prototype.convertAndCacheOnCPU=function(e,n){var t=this.tensorMap.get(e);return this.maybeReleaseBuffer(e),t.values=n,t.values},t.prototype.readSync=function(e){var n=this.tensorMap.get(e).values;if(null==n)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n},t.prototype.read=function(e){return o(this,void 0,void 0,(function(){var t,r,i,o,u,s,l;return a(this,(function(a){switch(a.label){case 0:if(!this.tensorMap.has(e))throw new Error("Tensor "+e+" was not registered!");return t=this.tensorMap.get(e),null!=(r=t.values)?[2,this.convertAndCacheOnCPU(e,r)]:"complex64"!==t.dtype?[3,2]:[4,Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)])];case 1:return o=a.sent(),u=o[0],s=o[1],i=n.backend_util.mergeRealAndImagArrays(u,s),[3,6];case 2:return null==t.values?[3,3]:(l=t.values,[3,5]);case 3:return[4,this.getBufferData(t.bufferInfo.buffer,t.bufferInfo.byteSize)];case 4:l=a.sent(),a.label=5;case 5:i=B(l,t.dtype),a.label=6;case 6:return this.convertAndCacheOnCPU(e,i),[2,i]}}))}))},t.prototype.readToGPU=function(e){var t=this.tensorMap.get(e),r=t.values,i=t.dtype,o=t.shape,a=t.bufferInfo;if("complex64"===i)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==a.buffer)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");var u=n.util.sizeFromShape(o)*N(i),s=this.acquireBuffer(u);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(a.buffer,0,s,0,u),this.submitQueue();var l=this.makeTensorInfo(o,i),d=n.engine().makeTensorFromTensorInfo(l);return this.tensorMap.get(l.dataId).bufferInfo.buffer=s,{tensorRef:d,buffer:s,bufSize:u}},t.prototype.bufferSync=function(e){var t=this.readSync(e.dataId);if("string"===e.dtype)try{var r=t.map((function(e){return n.util.decodeString(e)}));return n.buffer(e.shape,e.dtype,r)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return n.buffer(e.shape,e.dtype,t)},t.prototype.time=function(e){return o(this,void 0,void 0,(function(){var t,r,i,o,u,s,l;return a(this,(function(a){switch(a.label){case 0:return t=this.activeTimers,r=[],i=!1,null==this.programTimersStack?(this.programTimersStack=r,i=!0):this.activeTimers.push(r),this.activeTimers=r,e(),o=n.util.flatten(this.activeTimers.map((function(e){return e.query}))).filter((function(e){return null!=e})),u=n.util.flatten(this.activeTimers.map((function(e){return e.name}))).filter((function(e){return null!=e})),this.activeTimers=t,i&&(this.programTimersStack=null),s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},[4,Promise.all(o)];case 1:return l=a.sent(),s.kernelMs=n.util.sum(l),s.getExtraProfileInfo=function(){return l.map((function(e,n){return{name:u[n],ms:e}})).map((function(e){return e.name+": "+e.ms})).join(", ")},this.uploadWaitMs=0,this.downloadWaitMs=0,[2,s]}}))}))},t.prototype.getAndSavePipeline=function(e,n){return e in this.pipelineCache||(this.pipelineCache[e]=n()),this.pipelineCache[e]},t.prototype.makeTensorInfo=function(e,t,r){var i;if("string"===t&&null!=r&&r.length>0&&n.util.isString(r[0])){var o=r.map((function(e){return n.util.encodeString(e)}));i=this.write(o,e,t)}else i=this.write(r,e,t);return{dataId:i,shape:e,dtype:t}},t.prototype.tensorToBinding=function(e){if(!e)return null;var n=this.tensorMap.get(e.dataId);return{offset:0,size:n.bufferInfo.byteSize,buffer:n.bufferInfo.buffer}},t.prototype.getQueryTime=function(e){return o(this,void 0,void 0,(function(){return a(this,(function(n){return this.supportTimeQuery?[2,this.getTimeFromQuerySet(e)]:[2,0]}))}))},t.prototype.uploadToGPU=function(e){var n=this.tensorMap.get(e);if(null==n.bufferInfo.buffer&&(n.bufferInfo.buffer=this.acquireBuffer(n.bufferInfo.byteSize),n.values)){var t=this.bufferManager.acquireUploadBuffer(n.bufferInfo.byteSize,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),r=t.getMappedRange();"int32"===n.dtype||"bool"===n.dtype?new Int32Array(r).set(n.values):new Float32Array(r).set(n.values),t.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(t,0,n.bufferInfo.buffer,0,n.bufferInfo.byteSize);var i={byteSize:n.bufferInfo.byteSize,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:t};this.stagingDisposalQueue.push(i)}},t.prototype.makeUniforms=function(e){var t=0,r=0,i=[];e.forEach((function(e){var o;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:o=4;break;case 2:o=8;break;case 3:case 4:case 5:case 6:o=16;break;default:n.util.assert(!1,(function(){return"Unsupported "+e.data.length+"D shape"}))}5!==r&&6!==r||(o=16),t=Math.ceil(t/o)*o,r=e.data.length,i.push(t),t+=4*e.data.length}));var o=new ArrayBuffer(t);e.forEach((function(e,n){var t=i[n];"int32"===e.type?new Int32Array(o,t,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(o,t,e.data.length).set(e.data):new Float32Array(o,t,e.data.length).set(e.data)}));var a=this.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(a,0,o,0,t);var u={byteSize:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:a};return this.uniformDisposalQueue.push(u),{offset:0,size:t,buffer:a}},t.prototype.createLayout=function(e){var n=[];n.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}});for(var t=0;t<e;t++)n.push({binding:t+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}});n.push({binding:e+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}});var r=this.device.createBindGroupLayout({entries:n});return{bindGroupLayout:r,pipelineLayout:this.device.createPipelineLayout({bindGroupLayouts:[r]})}},t.prototype.getCachedOrCreateLayout=function(e){return e in this.layoutCache||(this.layoutCache[e]=this.createLayout(e)),this.layoutCache[e]},t.prototype.runWebGPUProgram=function(e,t,r,i,o){var a=this;if(!o){if(o=this.makeTensorInfo(e.outputShape,r),0===n.util.sizeFromShape(o.shape))return this.tensorMap.get(o.dataId).values=n.util.getTypedArrayFromDType(o.dtype,0),o;this.uploadToGPU(o.dataId)}e.dispatch=Qi(this.device,e);var u=[{type:"float32",data:[NaN]}],s=t.concat(o).map((function(e){return e.shape})),d="int32";s.map((function(e){u.push({type:d,data:e})}));var p=n.util.computeStrides(o.shape);if(u.push({type:d,data:p}),e.size){var c=n.util.sizeFromShape(e.outputShape);u.push({type:d,data:[e.isVec4?c/4:c]})}i&&(u=l(u,i));var h=this.makeUniforms(u),f=t.map((function(n,t){if("complex64"===n.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return a.uploadToGPU(n.dataId),{dtype:a.tensorMap.get(n.dataId).dtype,shape:n.shape,name:e.variableNames[t]}})),m=f.map((function(e){return e.dtype})).concat(o.dtype),v=f.map((function(e){return n.backend_util.getBroadcastDims(e.shape,o.shape)})),g=f.map((function(e){return n.util.arraysEqual(e.shape,o.shape)})).join("_"),b=v.map((function(e){return e.join("_")})).join(";"),k=ji(e,s,m,b,g),I=this.getCachedOrCreateLayout(e.variableNames.length),x=I.bindGroupLayout,w=I.pipelineLayout,y=this.getAndSavePipeline(k,(function(){return qi(a.device,e,w,f,o)})),S=null!=this.activeTimers,C=function(e,n,t,r,i){var o=l([r],t);return i&&o.push(i),e.createBindGroup({layout:n,entries:o.map((function(e,n){return{binding:n,resource:e}}))})}(this.device,x,t.map((function(e){return a.tensorToBinding(e)})),this.tensorToBinding(o),h);this.ensureCommandEncoderReady();var z=this.getComputePass();return S&&this.supportTimeQuery&&z.writeTimestamp(this.querySet,0),z.setPipeline(y),z.setBindGroup(0,C),z.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),S&&this.supportTimeQuery&&z.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach((function(e){a.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(o.dataId),n.env().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),S&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),o},t.prototype.getFromPixelTextureLayout=function(e){return e?(null===this.fromPixelImportTextureLayout&&(this.fromPixelImportTextureLayout=this.createFromPixelTextureLayout(!0)),this.fromPixelImportTextureLayout):(null===this.fromPixelTextureLayout&&(this.fromPixelTextureLayout=this.createFromPixelTextureLayout(!1)),this.fromPixelTextureLayout)},t.prototype.createFromPixelTextureLayout=function(e){var n=[];n.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),e?n.push({binding:1,visibility:GPUShaderStage.COMPUTE,externalTexture:{}}):n.push({binding:1,visibility:GPUShaderStage.COMPUTE,texture:{}}),n.push({binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{}});var t=this.device.createBindGroupLayout({entries:n});return{bindGroupLayout:t,pipelineLayout:this.device.createPipelineLayout({bindGroupLayouts:[t]})}},t.prototype.copyExternalImageToTexture=function(e,n){var t=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,r="rgba8unorm",i=this.textureManager.acquireTexture(n[1],n[0],r,t),o=i.createView();this.queue.copyExternalImageToTexture({source:e},{texture:i},[n[1],n[0]]);var a={width:n[1],height:n[0],format:r,usage:t,texture:i};return this.textureDisposalQueue.push(a),o},t.prototype.runFromPixelsProgram=function(e,t,r,i,o){var a=this;e.dispatch=Qi(this.device,e);var u=this.makeTensorInfo(t,"int32");if(0===n.util.sizeFromShape(u.shape))return this.tensorMap.get(u.dataId).values=n.util.getTypedArrayFromDType(u.dtype,0),u;this.uploadToGPU(u.dataId);var s,l=ji(e,[u.shape]),d=this.getFromPixelTextureLayout(i),p=this.getAndSavePipeline(l,(function(){return qi(a.device,e,d.pipelineLayout,[],u,!0)}));if(i){var c={source:o};s=this.device.importExternalTexture(c)}else s=this.copyExternalImageToTexture(o,u.shape);var h=this.tensorToBinding(u),f=this.makeUniforms(r),m=this.device.createBindGroup({layout:d.bindGroupLayout,entries:[{binding:0,resource:{buffer:h.buffer}},{binding:1,resource:s},{binding:2,resource:{buffer:f.buffer}}]});this.ensureCommandEncoderReady();var v=this.getComputePass(),g=null!=this.activeTimers;return g&&this.supportTimeQuery&&v.writeTimestamp(this.querySet,0),v.setPipeline(p),v.setBindGroup(0,m),v.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),g&&this.supportTimeQuery&&v.writeTimestamp(this.querySet,1),this.commandQueueOwnedIds.add(u.dataId),this.dispatchNumberInEncoder++,n.env().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),g&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),u},t.prototype.getTimeFromQuerySet=function(e){return o(this,void 0,void 0,(function(){var n,t,r,i;return a(this,(function(o){switch(o.label){case 0:return n=this.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),t=this.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,n,0),this.currentCommandEncoder.copyBufferToBuffer(n,0,t,0,16),this.submitQueue(),[4,t.mapAsync(GPUMapMode.READ)];case 1:return o.sent(),r=new BigUint64Array(t.getMappedRange()),i=Number(r[1]-r[0]),t.unmap(),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),[2,i/1e6]}}))}))},t.prototype.shouldExecuteOnCPU=function(e,t){var r=this;return void 0===t&&(t=Ki),n.env().getBool("WEBGPU_CPU_FORWARD")&&e.every((function(e){return null==r.tensorMap.get(e.dataId).bufferInfo.buffer&&n.util.sizeFromShape(e.shape)<t}))},t.prototype.numDataIds=function(){return this.tensorMap.numDataIds()-this.tensorDisposalQueue.length},t.prototype.dispose=function(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)},t}(n.KernelBackend);Zi.nextDataId=0;var Ji={__proto__:null,webgpu_util:W,WebGPUBackend:Zi};L()&&n.registerBackend("webgpu",(function(){return o(undefined,void 0,void 0,(function(){var e,t,r,i,o,u;return a(this,(function(a){switch(a.label){case 0:return n.env().set("CHECK_COMPUTATION_FOR_ERRORS",!1),e={powerPreference:n.env().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},[4,navigator.gpu.requestAdapter(e)];case 1:return t=a.sent(),r=t.limits,i={},o=t.features.has("timestamp-query"),i.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension},o?i.requiredFeatures=["timestamp-query"]:console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Or zero will shown for the kernel time when profiling mode isenabled. Using performance.now is not workable for webgpu sinceit doesn't support synchronously to read data from GPU."),[4,t.requestDevice(i)];case 2:return u=a.sent(),[2,new Zi(u,o)]}}))}))}),3),e.webgpu=Ji,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-webgpu.min.js.map
